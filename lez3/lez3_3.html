<!DOCTYPE html>
<html lang="it">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>4BIA – Lez3_3 · File binari (base) in C++ e C</title>
  <link rel="stylesheet" href="../style.css">
  <link rel="stylesheet" href="../default.css">
  <script src="../highlight.js"></script>
  <script>try{hljs.highlightAll();}catch(e){}</script>
  <script>
    function prevSlide(){ window.location.href = "lez3_2.html"; }
    function nextSlide(){ window.location.href = "lez3_4.html"; }
    function toggleMenu(){ document.getElementById('menu').classList.toggle('open'); }
    function toggleBox(btnId, boxId){
      const box=document.getElementById(boxId), btn=document.getElementById(btnId);
      const open = box.style.display==='block';
      box.style.display = open ? 'none':'block';
      if(btn) btn.textContent = open ? 'Mostra ▼' : 'Nascondi ▲';
    }
  </script>
  <style>
    /* stile box + colorate */
    .box { background:var(--panel,#fff); border-radius:12px; padding:12px; box-shadow:0 2px 6px rgba(0,0,0,.08); margin-bottom:14px }
    .note { background:#f7faff; border-left:4px solid #3b82f6; padding:.6rem .8rem; border-radius:8px; margin:.35rem 0 }
    .warn { background:#fff7ed; border-left:4px solid #f59e0b; padding:.6rem .8rem; border-radius:8px; margin:.35rem 0 }
    .ok   { background:#eefbf1; border-left:4px solid #22c55e; padding:.6rem .8rem; border-radius:8px; margin:.35rem 0; display:inline-block }
    .tip  { font-style: italic; opacity:.95 }

    /* allineamento a sinistra nelle inner-box */
    .inner-box, .inner-box p, .inner-box ul, .inner-box ol, .inner-box li, .inner-box pre, .inner-box code { text-align:left !important; }
    .inner-box ul, .inner-box ol { margin:.5rem 0 .75rem 1rem; padding-left:1.25rem; list-style-position:outside }
    .inner-box li { margin:.25rem 0 }

    /* code block */
    pre { white-space: pre; tab-size: 4; margin:0 0 1rem 0; padding:.5rem .75rem }
    pre code { display:block; text-align:left !important; }

    table { width:100%; border-collapse: collapse; }
    th, td { border-bottom:1px solid #e5e7eb; padding:.45rem .5rem; vertical-align:top; text-align:left }
    th { background:#f8fafc }
    .mini { font-size:.95rem }
  </style>
</head>
<body>
<!-- BEGIN MENU -->
<button class="menu-toggle" onclick="toggleMenu()">&#9776; Menu</button>
<div class="sidebar" id="menu">
  <h2>Lezione 3 — File I/O</h2>
  <ul>
    <li><a href="lez3_1.html">Lez3_1: File: concetti e modelli</a></li>
    <li><a href="lez3_2.html">Lez3_2: I/O su file testuali (C++)</a></li>
    <li><a href="lez3_3.html" class="active">Lez3_3: File binari (base) in C++ e C</a></li>
    <li><a href="lez3_4.html">Lez3_4: Binari portabili (formati)</a></li>
    <li><a href="lez3_5.html">Lez3_5: Perché non scrivere struct “raw”</a></li>
    <li><a href="lez3_6.html">Lez3_6: fseek/ftell &amp; seekg/tellg (text mode)</a></li>
    <li><a href="lez3_7.html">Lez3_7: Indici per file binari</a></li>
  </ul>
</div>
<!-- END MENU -->

<div class="slide">
  <h1>Lez3_3 — File <em>binari</em> (base) in C++ e C</h1>

  <div class="nav-buttons" style="margin-bottom:10px">
    <button onclick="prevSlide()">&#8592; Indietro</button>
    <button onclick="nextSlide()">Avanti &#8594;</button>
  </div>

  <div class="content-box">

    <div class="inner-box">
      <h2>Obiettivo (versione base, stessa macchina)</h2>
      <ul>
        <li>Aprire file in <strong>modalità binaria</strong> e usare <code>write/read</code> (C++) o <code>fwrite/fread</code> (C).</li>
        <li>Serializzare/deserializzare:
          <ul>
            <li><strong>primitivi</strong> (es. <code>int</code>, <code>double</code>)</li>
            <li><strong>array 1D</strong> di primitivi</li>
            <li><strong>matrici 2D</strong> di primitivi (row-major)</li>
            <li><strong>array di struct</strong> con campi POD (<code>char[]</code>, numeri)</li>
          </ul>
        </li>
      </ul>
      <p class="note">Non trattiamo qui endianness/versioning generale; per portabilità cross-platform vedi Lez3_4.</p>
    </div>

    <div class="inner-box box">
      <h2>Cosa significa “binario” e perché <code>binary</code>?</h2>
      <ul>
        <li><strong>File binario</strong>: leggi/scrivi direttamente i <em>byte</em> degli oggetti, senza conversione in testo.</li>
        <li>C++: aggiungi <code>std::ios::binary</code>. C: usa <code>"rb"</code>/<code>"wb"</code>. <span class="ok">Eviti traduzioni di newline.</span></li>
        <li><strong>Formato</strong>: non c’è “magia” — decidi tu l’ordine dei dati nel file; per questo è utile un <em>header</em>.</li>
      </ul>
      <p class="tip">Per collezioni salva sempre prima la <strong>dimensione</strong> (es. <code>n</code>), poi i <strong>n</strong> elementi contigui.</p>
    </div>

    <!-- NEW: Contratto di formato minimale -->
    <div class="inner-box box">
      <h2>Contratto di formato <em>minimale</em> (consigliato anche nel “base”)</h2>
      <ul>
        <li><strong>Magic</strong> (es. 3 byte + <code>\0</code>) per riconoscere il file, es. <code>"B1\0"</code>.</li>
        <li><strong>Versione</strong> (<code>uint32_t</code>) per evoluzioni future.</li>
        <li><strong>Dimensioni</strong> (<code>n</code> elementi / <code>R</code>,<code>C</code> per matrici).</li>
      </ul>
      <p class="ok">Anche su “stessa macchina”, questa intestazione ti evita inconsistenti e facilita debug.</p>
    </div>

    <div class="inner-box box">
      <h2>Cos’è un <em>POD</em> (Plain Old Data) — perché lo usiamo qui</h2>
      <ul>
        <li><strong>POD</strong>: tipo con layout semplice e copiabile byte-a-byte, senza puntatori nascosti o invarianti.</li>
        <li><strong>Esempi</strong>: primitivi (<code>int</code>, <code>double</code>), array di primitivi, struct di soli <code>char[]</code> e numeri.</li>
      </ul>
      <h3>Controesempi (non-POD) & come serializzarli</h3>
      <ul>
        <li><code>std::string</code> → contiene puntatori. <span class="ok">Salva come <code>uint32_t len</code> + <em>len</em> byte UTF-8.</span></li>
        <li><code>std::vector&lt;T&gt;</code> → l’oggetto non è un blob contiguo. <span class="ok">Salva <code>n</code> + buffer <code>data()</code> (se <code>T</code> è POD).</span></li>
        <li><strong>Puntatori</strong> → un indirizzo non ha senso su disco. <span class="ok">Salva il contenuto o un ID.</span></li>
      </ul>
      <p class="warn">Evita bit-field e <code>bool</code> “raw” (size implementation-defined) nei file base.</p>
    </div>

    <!-- ===================== C++ ===================== -->
    <div class="inner-box">
      <h2>Sezione C++ — esempi in modalità binaria</h2>

      <div class="inner-box box">
        <h3>1) Primitivi (con header minimale)</h3>
        <p class="mini"><strong>Algoritmo in parole</strong> — Scrittura: apri file in binario → scrivi <em>magic</em>, <em>versione</em>, <em>count</em> → scrivi i due valori (<code>int</code>, <code>double</code>) usando <code>write</code> che prende un puntatore ai byte e la dimensione. Lettura: apri in binario → leggi header → leggi i due valori con <code>read</code> negli indirizzi delle variabili.</p>
        <p class="mini"><strong>Cosa fanno le chiamate</strong> — <code>out.write((const char*)&x, sizeof x)</code> copia su file i <em>sizeof(x)</em> byte attualmente in memoria per <code>x</code>. <code>in.read((char*)&x, sizeof x)</code> fa l’inverso. 
		<br/><br/>
		<span class="warn">Portabilità:</span> così scrivi il layout “nativo” (endianness, padding): bene per “stessa macchina”, non cross-platform (vedi Lez3_4).</p>
<pre><code class="language-cpp">#include &lt;fstream&gt;
#include &lt;cstdint&gt;
#include &lt;iostream&gt;

int main(){
    // SCRITTURA
    {
        std::ofstream out("prim.bin", std::ios::binary);
        if(!out){ std::cerr &lt;&lt; "open write\n"; return 1; }
        const char magic[3] = {'B','1','\0'};
        std::uint32_t ver = 1, count = 2;
        out.write((const char*)magic, sizeof magic);
        out.write((const char*)&ver, sizeof ver);
        out.write((const char*)&count, sizeof count);

        int    a = 42;
        double b = 3.14159;
        out.write((const char*)&a, sizeof a);
        out.write((const char*)&b, sizeof b);
    }
    // LETTURA
    {
        std::ifstream in("prim.bin", std::ios::binary);
        if(!in){ std::cerr &lt;&lt; "open read\n"; return 1; }
        char magic[3]; std::uint32_t ver=0,count=0;
        in.read((char*)magic, 3);
        in.read((char*)&ver, sizeof ver);
        in.read((char*)&count, sizeof count);
        int a; double b;
        in.read((char*)&a, sizeof a);
        in.read((char*)&b, sizeof b);
        std::cout &lt;&lt; "magic=" &lt;&lt; magic &lt;&lt; " ver=" &lt;&lt; ver
                  &lt;&lt; " a=" &lt;&lt; a &lt;&lt; " b=" &lt;&lt; b &lt;&lt; "\n";
    }
}
</code></pre>
      </div>

      <div class="inner-box box">
        <h3>2) Array 1D di primitivi</h3>
        <p class="mini"><strong>Algoritmo</strong> — Scrivi: header, poi <code>n=vector.size()</code>, poi i <em>n</em> elementi contigui dal buffer <code>v.data()</code>. Leggi: header → <code>n</code> → ridimensiona <code>vector</code> → leggi in blocco nel suo buffer.</p>
        <p class="mini"><strong>Perché funziona</strong> — <code>std::vector</code> garantisce che gli elementi siano contigui in memoria; <code>data()</code> restituisce un puntatore al primo elemento, utilizzabile da <code>read/write</code>.</p>
<pre><code class="language-cpp">#include &lt;vector&gt;
#include &lt;cstdint&gt;
#include &lt;fstream&gt;

int main(){
    // SCRITTURA
    {
        std::vector&lt;int&gt; v = {1,2,3,4,5};
        std::ofstream out("array.bin", std::ios::binary);
        if(!out) return 1;
        const char magic[3]={'B','1','\0'}; std::uint32_t ver=1;
        std::uint32_t n = (std::uint32_t)v.size();
        out.write((const char*)magic,3);
        out.write((const char*)&ver,sizeof ver);
        out.write((const char*)&n,  sizeof n);
        out.write((const char*)v.data(), n*sizeof(int));
    }
    // LETTURA
    {
        std::ifstream in("array.bin", std::ios::binary);
        if(!in) return 1;
        char magic[3]; std::uint32_t ver=0,n=0;
        in.read((char*)magic,3); in.read((char*)&ver,sizeof ver); in.read((char*)&n,sizeof n);
        std::vector&lt;int&gt; v(n);
        in.read((char*)v.data(), n*sizeof(int));
        // ... usa v ...
    }
}
</code></pre>
      </div>

      <div class="inner-box box">
        <h3>3) Matrice 2D di primitivi (row-major)</h3>
        <p class="mini"><strong>Algoritmo</strong> — Rappresentiamo la matrice come unico vettore di lunghezza <code>R*C</code> in <em>row-major</em> (prima riga, poi la seconda, ...). Scriviamo header + <code>R</code>, <code>C</code> + blocco <code>R*C</code> elementi. In lettura, ricostruiamo un vettore di pari dimensione e usiamo l’indice <code>r*C + c</code>.</p>
        <p class="mini"><strong>Perché</strong> — Usare un buffer lineare evita complicazioni con array di puntatori e rende la scrittura/lettura un’unica operazione di blocco.</p>
<pre><code class="language-cpp">#include &lt;vector&gt;
#include &lt;cstdint&gt;
#include &lt;fstream&gt;

int main(){
    const std::uint32_t R=2, C=3;
    std::vector&lt;double&gt; m = {1,2,3, 4,5,6};

    // SCRITTURA
    {
        std::ofstream out("mat.bin", std::ios::binary);
        if(!out) return 1;
        const char magic[3]={'B','1','\0'}; std::uint32_t ver=1;
        out.write((const char*)magic,3);
        out.write((const char*)&ver,sizeof ver);
        out.write((const char*)&R,  sizeof R);
        out.write((const char*)&C,  sizeof C);
        out.write((const char*)m.data(), R*C*sizeof(double));
    }
    // LETTURA
    {
        std::ifstream in("mat.bin", std::ios::binary);
        if(!in) return 1;
        char magic[3]; std::uint32_t ver=0,R2=0,C2=0;
        in.read((char*)magic,3); in.read((char*)&ver,sizeof ver);
        in.read((char*)&R2,sizeof R2); in.read((char*)&C2,sizeof C2);
        std::vector&lt;double&gt; m2(R2*C2);
        in.read((char*)m2.data(), R2*C2*sizeof(double));
        // ... usa m2[r*C2 + c] ...
    }
}
</code></pre>
      </div>

      <div class="inner-box box">
        <h3>4) Array di <em>struct</em> (solo campi POD)</h3>
        <p class="mini"><strong>Algoritmo</strong> — Dichiarare una struct “POD-style” (solo <code>char[]</code>, numeri). Scrivere: header + <code>n</code> + blocco <code>n*sizeof(Studente)</code> prelevato dal buffer contiguo del <code>vector</code>. Leggere: header + <code>n</code> → ridimensiona → <code>read</code> in blocco.</p>
        <p class="mini"><strong>Perché <code>char[32]</code> e non <code>std::string</code></strong> — <code>std::string</code> ha puntatori/capacità interni: il dump “grezzo” non rappresenta il testo. Con <code>char[]</code> i byte del nome sono <em>davvero</em> nel record.</p>
<pre><code class="language-cpp">#include &lt;vector&gt;
#include &lt;cstdint&gt;
#include &lt;cstring&gt;
#include &lt;fstream&gt;

struct Studente {
    char   nome[32];
    char   cognome[32];
    int    eta;
    double media;
};

int main(){
    std::vector&lt;Studente&gt; cls(2);
    std::strncpy(cls[0].nome,"Ada",31); cls[0].nome[31]='\0';
    std::strncpy(cls[0].cognome,"Lovelace",31); cls[0].cognome[31]='\0';
    cls[0].eta=17; cls[0].media=9.4;

    std::strncpy(cls[1].nome,"Alan",31); cls[1].nome[31]='\0';
    std::strncpy(cls[1].cognome,"Turing",31); cls[1].cognome[31]='\0';
    cls[1].eta=18; cls[1].media=10.0;

    // SCRITTURA
    {
        std::ofstream out("studenti.bin", std::ios::binary);
        if(!out) return 1;
        const char magic[3]={'B','1','\0'}; std::uint32_t ver=1, n=(std::uint32_t)cls.size();
        out.write((const char*)magic,3);
        out.write((const char*)&ver,sizeof ver);
        out.write((const char*)&n,  sizeof n);
        out.write((const char*)cls.data(), n*sizeof(Studente));
    }
    // LETTURA
    {
        std::ifstream in("studenti.bin", std::ios::binary);
        if(!in) return 1;
        char magic[3]; std::uint32_t ver=0,n=0;
        in.read((char*)magic,3); in.read((char*)&ver,sizeof ver); in.read((char*)&n,sizeof n);
        std::vector&lt;Studente&gt; v(n);
        in.read((char*)v.data(), n*sizeof(Studente));
        // ... usa v ...
    }
}
</code></pre>
      </div>
    </div>

    <!-- ===================== C ===================== -->
    <div class="inner-box">
      <h2>Sezione C — esempi in modalità binaria</h2>

      <div class="inner-box box">
        <h3>1) Primitivi (con header minimale)</h3>
        <p class="mini"><strong>Algoritmo</strong> — Scrivi: header + valori con <code>fwrite</code>. Leggi: header + valori con <code>fread</code>. <strong>Semantica</strong>: <code>fwrite(ptr, size, count, f)</code> prova a scrivere <em>count</em> oggetti da <em>size</em> byte presi da <em>ptr</em>; restituisce quanti ne ha scritti. <code>fread</code> fa l’opposto. Nel codice didattico omettiamo i check sul valore di ritorno, ma in produzione vanno controllati.</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdint.h&gt;

int main(void){
    // SCRITTURA
    {
        FILE* f = fopen("prim_c.bin","wb"); if(!f) return 1;
        const char magic[3] = {'B','1','\0'};
        uint32_t ver=1, count=2;
        fwrite(magic, 1, 3, f);
        fwrite(&ver,  1, sizeof ver, f);
        fwrite(&count,1, sizeof count, f);

        int a=42; double b=3.14159;
        fwrite(&a, 1, sizeof a, f);
        fwrite(&b, 1, sizeof b, f);
        fclose(f);
    }
    // LETTURA
    {
        FILE* f = fopen("prim_c.bin","rb"); if(!f) return 1;
        char magic[3]; uint32_t ver=0,count=0;
        fread(magic,1,3,f); fread(&ver,1,sizeof ver,f); fread(&count,1,sizeof count,f);
        int a; double b;
        fread(&a,1,sizeof a,f); fread(&b,1,sizeof b,f);
        fclose(f);
        return 0;
    }
}
</code></pre>
      </div>

      <div class="inner-box box">
        <h3>2) Array 1D di primitivi</h3>
        <p class="mini"><strong>Algoritmo</strong> — Scrivi: header + <code>n</code> + blocco <code>n</code> interi con un’unica <code>fwrite</code>. Leggi: header → <code>n</code> → <code>malloc</code> di <code>n*sizeof(int)</code> → <code>fread</code> del blocco.</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdint.h&gt;
#include &lt;stdlib.h&gt;

int main(void){
    // SCRITTURA
    {
        int v[] = {1,2,3,4,5};
        uint32_t n = (uint32_t)(sizeof v / sizeof v[0]);
        FILE* f = fopen("array_c.bin","wb"); if(!f) return 1;
        const char magic[3]={'B','1','\0'}; uint32_t ver=1;
        fwrite(magic,1,3,f); fwrite(&ver,1,sizeof ver,f); fwrite(&n,1,sizeof n,f);
        fwrite(v, sizeof(int), n, f);
        fclose(f);
    }
    // LETTURA
    {
        FILE* f = fopen("array_c.bin","rb"); if(!f) return 1;
        char magic[3]; uint32_t ver=0,n=0;
        fread(magic,1,3,f); fread(&ver,1,sizeof ver,f); fread(&n,1,sizeof n,f);
        int* v = (int*)malloc(n*sizeof(int)); if(!v){ fclose(f); return 1; }
        fread(v, sizeof(int), n, f);
        // ... usa v ...
        free(v); fclose(f); return 0;
    }
}
</code></pre>
      </div>

      <div class="inner-box box">
        <h3>3) Matrice 2D di primitivi (row-major)</h3>
        <p class="mini"><strong>Algoritmo</strong> — Scrivi: header + <code>R</code>, <code>C</code> + blocco lineare di <code>R*C</code> double. Leggi: header → <code>R</code>, <code>C</code> → <code>malloc</code> di <code>R*C</code> elementi → <code>fread</code> del blocco. Accedi con <code>m[r*C + c]</code>.</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdint.h&gt;
#include &lt;stdlib.h&gt;

int main(void){
    uint32_t R=2, C=3;
    double m[6] = {1,2,3, 4,5,6};

    // SCRITTURA
    {
        FILE* f = fopen("mat_c.bin","wb"); if(!f) return 1;
        const char magic[3]={'B','1','\0'}; uint32_t ver=1;
        fwrite(magic,1,3,f); fwrite(&ver,1,sizeof ver,f);
        fwrite(&R,1,sizeof R,f); fwrite(&C,1,sizeof C,f);
        fwrite(m, sizeof(double), R*C, f);
        fclose(f);
    }
    // LETTURA
    {
        FILE* f = fopen("mat_c.bin","rb"); if(!f) return 1;
        char magic[3]; uint32_t ver=0,R2=0,C2=0;
        fread(magic,1,3,f); fread(&ver,1,sizeof ver,f);
        fread(&R2,1,sizeof R2,f); fread(&C2,1,sizeof C2,f);
        double* m2 = (double*)malloc(R2*C2*sizeof(double)); if(!m2){ fclose(f); return 1; }
        fread(m2, sizeof(double), R2*C2, f);
        // ... usa m2[r*C2 + c] ...
        free(m2); fclose(f); return 0;
    }
}
</code></pre>
      </div>

      <div class="inner-box box">
        <h3>4) Array di <em>struct</em> (C) — solo campi POD</h3>
        <p class="mini"><strong>Algoritmo</strong> — Scrivi: header + <code>n</code> + blocco <code>n*sizeof(Studente)</code>. Leggi: header → <code>n</code> → buffer statico o dinamico → <code>fread</code> del blocco.</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdint.h&gt;
#include &lt;string.h&gt;

typedef struct {
    char   nome[32];
    char   cognome[32];
    int    eta;
    double media;
} Studente;

int main(void){
    Studente cls[2]; memset(&cls,0,sizeof cls);
    strncpy(cls[0].nome,"Ada",31); strncpy(cls[0].cognome,"Lovelace",31); cls[0].eta=17; cls[0].media=9.4;
    strncpy(cls[1].nome,"Alan",31); strncpy(cls[1].cognome,"Turing",31);   cls[1].eta=18; cls[1].media=10.0;

    // SCRITTURA
    {
        FILE* f = fopen("studenti_c.bin","wb"); if(!f) return 1;
        const char magic[3]={'B','1','\0'}; uint32_t ver=1, n=2;
        fwrite(magic,1,3,f); fwrite(&ver,1,sizeof ver,f); fwrite(&n,1,sizeof n,f);
        fwrite(cls, sizeof(Studente), n, f);
        fclose(f);
    }
    // LETTURA
    {
        FILE* f = fopen("studenti_c.bin","rb"); if(!f) return 1;
        char magic[3]; uint32_t ver=0, n=0;
        fread(magic,1,3,f); fread(&ver,1,sizeof ver,f); fread(&n,1,sizeof n,f);
        Studente v[10]; if(n>10) n=10;
        fread(v, sizeof(Studente), n, f);
        fclose(f); return 0;
    }
}
</code></pre>
      </div>
    </div>

    <div class="inner-box">
      <h2>Pitfall (base) & accortezze</h2>
      <ul>
        <li><strong>Dimenticare la modalità binaria</strong> (<code>std::ios::binary</code>, <code>"wb"/"rb"</code>). <br/><br/><span class="ok">Apri sempre i file binari in modalità binaria.</span></li>
        <li><strong>Non salvare le dimensioni</strong> prima di array/matrici. <br/><br/><span class="ok">Scrivi prima <code>n</code> (o <code>R</code>, <code>C</code>), poi i dati.</span></li>
        <li><strong>Struct con campi non banali</strong> (<code>std::string</code>, puntatori). <br/><br/><span class="ok">Nel “base” usa solo campi POD, oppure serializza i contenuti (len+bytes).</span></li>
        <li><strong>Ignorare i risultati I/O</strong> (letture parziali). <br/><br/><span class="ok">In C verifica il valore di ritorno di <code>fread/fwrite</code>; in C++ verifica <code>!stream.fail()</code> o <code>gcount()</code> se leggi parziale.</span></li>
      </ul>
      <p class="note">Per formati portabili (endianness/versioni) → Lez3_4; per “perché non raw struct” → Lez3_5.</p>
    </div>

    <div class="inner-box">
      <h2>Takeaways</h2>
      <ul>
        <li>Binario (base) = scrivere/leggere <strong>byte</strong> di primitivi e POD in blocchi contigui.</li>
        <li>Inserisci un <strong>header minimale</strong> (magic+versione+dimensioni) anche negli esempi base.</li>
        <li>Per matrici: layout row-major e indice <code>r*C + c</code>.</li>
        <li>La portabilità generale è nella prossima lezione; qui consolidiamo le tecniche fondamentali.</li>
      </ul>
    </div>

  </div>

  <div class="nav-buttons">
    <button onclick="prevSlide()">&#8592; Indietro</button>
    <button onclick="nextSlide()">Avanti &#8594;</button>
  </div>
</div>

<script>
function toggleMenu(){ document.getElementById('menu').classList.toggle('open'); }
</script>
</body>
</html>
