<!DOCTYPE html>
<html lang="it">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>4BIA – Lez3_1 · File: concetti, tipi e modello d’I/O</title>
  <link rel="stylesheet" href="../style.css">
  <link rel="stylesheet" href="../default.css">
  <script src="../highlight.js"></script>
  <script>try{hljs.highlightAll();}catch(e){}</script>
  <script>
    function prevSlide(){ window.location.href = "../programma.html"; }
    function nextSlide(){ window.location.href = "lez3_2.html"; }
    function toggleMenu(){ document.getElementById('menu').classList.toggle('open'); }
    function toggleBox(btnId, boxId){
      const box=document.getElementById(boxId), btn=document.getElementById(btnId);
      const open = box.style.display==='block';
      box.style.display = open ? 'none':'block';
      if(btn) btn.textContent = open ? 'Mostra ▼' : 'Nascondi ▲';
    }
  </script>
  <style>
    /* Box base + colorate */
    .box { background:var(--panel,#fff); border-radius:12px; padding:12px; box-shadow:0 2px 6px rgba(0,0,0,.08); margin-bottom:14px }
    .note { background:#f7faff; border-left:4px solid #3b82f6; padding:.6rem .8rem; border-radius:8px; margin:.35rem 0 }
    .warn { background:#fff7ed; border-left:4px solid #f59e0b; padding:.6rem .8rem; border-radius:8px; margin:.35rem 0 }
    .ok   { background:#eefbf1; border-left:4px solid #22c55e; padding:.6rem .8rem; border-radius:8px; margin:.35rem 0; display:inline-block }
    .tip  { font-style: italic; opacity:.95 }

    /* Allineamento SEMPRE a sinistra nelle inner-box */
    .inner-box, .inner-box p, .inner-box ul, .inner-box ol, .inner-box li, .inner-box pre, .inner-box code { text-align: left !important; }
    .inner-box ul, .inner-box ol { margin: .5rem 0 .75rem 1rem; padding-left: 1.25rem; list-style-position: outside; }
    .inner-box li { margin: .25rem 0; }

    /* Code block leggibili */
    pre { white-space: pre; tab-size: 4; margin: 0 0 1rem 0; padding: .5rem .75rem; }
    pre code { display:block; text-align:left !important; }

    /* Tabelle */
    table { width:100%; border-collapse: collapse; }
    th, td { border-bottom: 1px solid #e5e7eb; padding: .45rem .5rem; vertical-align: top; text-align:left }
    th { background: #f8fafc; }

    .kbd, .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace; }
    .kbd { background:#f1f5f9; border:1px solid #e2e8f0; border-radius:6px; padding:0 .35rem }
  </style>
</head>
<body>
<!-- BEGIN MENU -->
<button class="menu-toggle" onclick="toggleMenu()">&#9776; Menu</button>
<div class="sidebar" id="menu">
  <h2>Lezione 3 — File I/O</h2>
  <ul>
    <li><a href="lez3_1.html" class="active">Lez3_1: File: concetti e modelli</a></li>
    <li><a href="lez3_2.html">Lez3_2: I/O su file testuali (C++)</a></li>
    <li><a href="lez3_3.html">Lez3_3: File binari (base) in C++ e C</a></li>
    <li><a href="lez3_4.html">Lez3_4: Binari portabili (formati)</a></li>
    <li><a href="lez3_5.html">Lez3_5: Perché non scrivere struct “raw”</a></li>
    <li><a href="lez3_6.html">Lez3_6: fseek/ftell &amp; seekg/tellg (text mode)</a></li>
    <li><a href="lez3_7.html">Lez3_7: Indici per file binari</a></li>
  </ul>
</div>
<!-- END MENU -->

<div class="slide">
  <h1>Lez3_1 — File: concetti, tipi e modello d’I/O (ripasso esteso)</h1>

  <div class="nav-buttons" style="margin-bottom:10px">
    <button onclick="prevSlide()">&#8592; Indietro</button>
    <button onclick="nextSlide()">Avanti &#8594;</button>
  </div>

  <div class="content-box">

    <div class="inner-box">
      <h2>Obiettivi</h2>
      <ul>
        <li>Capire cos’è un <strong>file</strong> e come lo gestisce l’OS (path, handle, permessi, buffering).</li>
        <li>Distinguere tra <strong>file testuali</strong> e <strong>file binari</strong> (pro/contro, quando usarli).</li>
        <li>Conoscere il <strong>modello d’I/O</strong>: apri → leggi/scrivi → (seek) → chiudi; gestire errori tipici.</li>
      </ul>
      <p class="note">Le lezioni successive mostrano il “come si fa” (C++ e C). Qui fissiamo le basi concettuali.</p>
    </div>

    <div class="inner-box box">
      <h2>Che cos’è un file (3 livelli)</h2>
      <table>
        <tr><th>Livello</th><th>Idea</th><th>Esempi/Note</th></tr>
        <tr>
          <td><strong>Logico</strong></td>
          <td>Una <em>sequenza di byte</em> che segue un <strong>formato</strong> (testo, immagine, archivio dati…)</td>
          <td>Il significato è dato dalle <em>regole del formato</em> (scelte dal programmatore o da uno standard)</td>
        </tr>
        <tr>
          <td><strong>OS</strong></td>
          <td>L’OS gestisce path, permessi, handle/descrittori, timestamp; espone chiamate per I/O</td>
          <td>Operazioni: apri/chiudi, leggi/scrivi, crea/cancella, rinomina, sposta</td>
        </tr>
        <tr>
          <td><strong>Fisico</strong></td>
          <td>I byte vivono su disco/SSD; il file system organizza blocchi e indici</td>
          <td>I dettagli fisici sono <em>astratti</em> dai livelli superiori</td>
        </tr>
      </table>
    </div>

    <div class="inner-box box">
      <h2>File testuali vs file binari</h2>
      <table>
        <tr><th>Tipo</th><th>Cos’è</th><th>Pro</th><th>Contro</th><th>Esempi d’uso</th></tr>
        <tr>
          <td><strong>Testuale</strong></td>
          <td>Byte che rappresentano <em>caratteri</em> secondo un’<strong>encoding</strong> (UTF-8, ecc.)</td>
          <td>Leggibile, diff-friendly, debug semplice</td>
          <td>Più spazio, parsing, attenzione a newline/locale</td>
          <td>Log, CSV/TSV, JSON, sorgenti</td>
        </tr>
        <tr>
          <td><strong>Binario</strong></td>
          <td>Byte “grezzi” con struttura decisa dal programma</td>
          <td>Compatto, veloce, ottimo per accesso casuale</td>
          <td>Non leggibile a occhio; servono specifiche (endianness/versioni)</td>
          <td>Immagini, audio, archivi dati efficienti</td>
        </tr>
      </table>
      <p class="tip"><strong>Encoding</strong>: in testuale useremo <em>UTF-8</em>. <strong>Newline</strong>: Windows usa CRLF (<span class="mono">\r\n</span>), Linux/macOS LF (<span class="mono">\n</span>).</p>
    </div>

    <div class="inner-box box">
      <h2>Percorsi, working directory, permessi</h2>
      <ul>
        <li><strong>Assoluto</strong>: dalla radice. Linux: <span class="kbd">/home/utente/dati/log.txt</span> — Windows: <span class="kbd">C:\Users\Utente\dati\log.txt</span></li>
        <li><strong>Relativo</strong>: dalla <em>working directory</em> del processo. Es.: <span class="kbd">./data/log.txt</span></li>
        <li><strong>Permessi</strong>: lettura/scrittura/esecuzione. Errori tipici: “<em>No such file or directory</em>”, “<em>Permission denied</em>”.</li>
      </ul>
      <p class="note">Nelle esercitazioni useremo percorsi semplici (file nella cartella del programma) per massima portabilità.</p>
    </div>

    <div class="inner-box box">
      <h2>Modello generale d’I/O</h2>
      <ol>
        <li><strong>Apri</strong> il file → ottieni uno <em>stream</em> (C++: `ifstream/ofstream/fstream`) o un <code>FILE*</code> (C).</li>
        <li><strong>Leggi/Scrivi</strong> → in <em>testo</em> (linee/parsificato) o in <em>binario</em> (byte secondo il tuo formato).</li>
        <li><strong>(Seek)</strong> posiziona il cursore se serve accesso casuale.</li>
        <li><strong>Chiudi</strong> (in C++ spesso RAII chiude in automatico).</li>
      </ol>
      <ul>
        <li><strong>Buffering</strong>: i dati passano da/verso un buffer; <em>flush</em> = scrittura forzata su disco.</li>
        <li><strong>Errori tipici</strong>: percorso errato, permessi, file occupato, disco pieno, formato inatteso.</li>
      </ul>
    </div>

    <!-- NEW: tabella decisionale testo vs binario -->
    <div class="inner-box box">
      <h2>Come scegliere: Testo o Binario? (tabella decisionale)</h2>
      <table>
        <tr><th>Criterio</th><th>Scegli TESTO</th><th>Scegli BINARIO</th></tr>
        <tr>
          <td>Leggibilità umana</td>
          <td class="ok">Sì: debug/edito con editor, versionamento (diff)</td>
          <td>No interesse alla lettura diretta</td>
        </tr>
        <tr>
          <td>Dimensioni/velocità</td>
          <td>Dati piccoli, frequenza bassa</td>
          <td class="ok">Dati voluminosi, I/O intensivo</td>
        </tr>
        <tr>
          <td>Interoperabilità</td>
          <td class="ok">Scambio con tool “office” (CSV/TSV)</td>
          <td>Pipeline proprietarie, protocolli compatti</td>
        </tr>
        <tr>
          <td>Accesso casuale</td>
          <td>Non necessario</td>
          <td class="ok">Sì: salto al record k, update in-place</td>
        </tr>
        <tr>
          <td>Controllo del formato</td>
          <td>Parsing semplice (CSV/JSON)</td>
          <td class="ok">Header/versione/endianness, layout preciso</td>
        </tr>
      </table>
      <p class="tip">Nel corso: testo per CSV/TSV e scambio; binario per efficienza e indici.</p>
    </div>

    <!-- NEW: cheat-sheet modalità apertura -->
    <div class="inner-box box">
      <h2>Cheat-sheet: modalità di apertura (C++ e C)</h2>
      <table>
        <tr><th>Operazione</th><th>C++ (iostream)</th><th>C (stdio)</th><th>Note</th></tr>
        <tr>
          <td>Leggi testo</td>
          <td><span class="mono">std::ifstream f("a.txt");</span></td>
          <td><span class="mono">fopen("a.txt","r")</span></td>
          <td>Su Windows la modalità testo traduce newline</td>
        </tr>
        <tr>
          <td>Scrivi testo (troncante)</td>
          <td><span class="mono">std::ofstream f("a.txt");</span></td>
          <td><span class="mono">fopen("a.txt","w")</span></td>
          <td>Tronca se esiste</td>
        </tr>
        <tr>
          <td>Append testo</td>
          <td><span class="mono">std::ofstream f("a.txt", std::ios::app);</span></td>
          <td><span class="mono">fopen("a.txt","a")</span></td>
          <td>Aggiunge in fondo</td>
        </tr>
        <tr>
          <td>Leggi binario</td>
          <td><span class="mono">std::ifstream f("d.bin", std::ios::binary);</span></td>
          <td><span class="mono">fopen("d.bin","rb")</span></td>
          <td class="ok">Nessuna traduzione newline</td>
        </tr>
        <tr>
          <td>Scrivi binario (troncante)</td>
          <td><span class="mono">std::ofstream f("d.bin", std::ios::binary);</span></td>
          <td><span class="mono">fopen("d.bin","wb")</span></td>
          <td>Tronca se esiste</td>
        </tr>
        <tr>
          <td>Append binario</td>
          <td><span class="mono">std::ofstream f("d.bin", std::ios::app|std::ios::binary);</span></td>
          <td><span class="mono">fopen("d.bin","ab")</span></td>
          <td>Aggiunge in fondo</td>
        </tr>
        <tr>
          <td>Lettura+scrittura</td>
          <td><span class="mono">std::fstream f("a.txt", std::ios::in|std::ios::out);</span></td>
          <td><span class="mono">fopen("a.txt","r+")</span></td>
          <td>Con binario: aggiungi <span class="mono">std::ios::binary</span> / <span class="mono">"b"</span></td>
        </tr>
      </table>
      <p class="note">C++: flag utili <span class="mono">std::ios::in|out|app|trunc|binary</span>. C: combinazioni <span class="mono">r/w/a</span> con <span class="mono">b</span> per binario.</p>
    </div>

    <div class="inner-box">
      <h2>Mini-assaggi di codice (forma generale)</h2>

      <div class="inner-box box">
        <h3>1) C++ · <em>lettura</em> testo (riga per riga)</h3>
<pre><code class="language-cpp">#include &lt;fstream&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;

int main(){
    std::ifstream in("dati.txt");      // TESTO (r)
    if (!in) { std::cerr &lt;&lt; "Errore apertura\n"; return 1; }
    std::string linea;
    while (std::getline(in, linea)) {
        std::cout &lt;&lt; "Letta: " &lt;&lt; linea &lt;&lt; "\n";
    }
}
</code></pre>
      </div>

      <div class="inner-box box">
        <h3>2) C++ · <em>scrittura</em> testo</h3>
<pre><code class="language-cpp">#include &lt;fstream&gt;
#include &lt;iostream&gt;

int main(){
    std::ofstream out("out.txt");      // TESTO (w, troncante)
    if (!out){ std::cerr &lt;&lt; "Errore apertura\n"; return 1; }
    out &lt;&lt; "Prima riga\n";
    out &lt;&lt; "Seconda riga\n";
}
</code></pre>
      </div>

      <div class="inner-box box">
        <h3>3) C · <em>lettura</em> testo (<code>fgets</code>)</h3>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

static void rstrip_crlf(char* s){
    size_t n = strlen(s);
    while (n &gt; 0 &amp;&amp; (s[n-1]=='\n' || s[n-1]=='\r')) s[--n] = '\0';
}

int main(void){
    FILE* f = fopen("dati.txt", "r");  // TESTO (r)
    if (!f) { perror("fopen"); return 1; }
    char buf[256];
    while (fgets(buf, sizeof buf, f)){
        rstrip_crlf(buf);
        printf("Letta: %s\n", buf);
    }
    fclose(f);
    return 0;
}
</code></pre>
      </div>

      <div class="inner-box box">
        <h3>4) C · <em>scrittura</em> testo</h3>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main(void){
    FILE* out = fopen("out.txt", "w"); // TESTO (w, troncante)
    if (!out) { perror("fopen"); return 1; }
    fprintf(out, "Prima riga\n");
    fprintf(out, "Seconda riga\n");
    fclose(out);
    return 0;
}
</code></pre>
      </div>

      <p class="tip">I dettagli pratici (CSV/TSV robusti, binario base/portabile, seek, indici) arrivano nelle prossime lezioni.</p>
    </div>

    <div class="inner-box">
      <h2>Esercizi di comprensione (con soluzioni a comparsa)</h2>
      <ol>
        <li><strong>E1 — Testo o binario?</strong><br/>
          <span>Hai un archivio di 10.000 studenti con nome, cognome, età e media. Scegli tra <em>testo</em> e <em>binario</em> e motiva pro/contro.</span>
          <div class="nav-buttons" style="justify-content:left"><button id="btn-e1" onclick="toggleBox('btn-e1','box-e1')">Mostra ▼</button></div>
          <div id="box-e1" style="display:none;margin-top:8px">
            <div class="ok">
              <p><strong>Possibile risposta:</strong> <em>Testo</em> se voglio leggibilità e editing manuale (CSV), facile scambio con fogli di calcolo. <em>Binario</em> se voglio file compatti/veloci (salvataggio frequente, grandi volumi) e controllo del layout. Per la classe, testo va benissimo; per un gestionale ad alte prestazioni, binario.</p>
            </div>
          </div>
        </li>

        <li><strong>E2 — Percorsi</strong><br/>
          <span>Qual è la differenza tra percorso <em>assoluto</em> e <em>relativo</em>? Fai un esempio in Windows e uno in Linux.</span>
          <div class="nav-buttons" style="justify-content:left"><button id="btn-e2" onclick="toggleBox('btn-e2','box-e2')">Mostra ▼</button></div>
          <div id="box-e2" style="display:none;margin-top:8px">
            <div class="ok">
              <p><strong>Soluzione:</strong> Assoluto: dalla radice (<span class="kbd">C:\</span> o <span class="kbd">/</span>). Es.: <span class="kbd">C:\Users\Mario\log.txt</span>, <span class="kbd">/home/mario/log.txt</span>.
              Relativo: rispetto alla cartella corrente. Es.: <span class="kbd">.\data\log.txt</span> (Win) o <span class="kbd">./data/log.txt</span> (Linux).</p>
            </div>
          </div>
        </li>

        <li><strong>E3 — Newline &amp; encoding</strong><br/>
          <span>Perché un file testuale creato su Windows può mostrare “stranezze” se aperto su Linux con editor vecchi?</span>
          <div class="nav-buttons" style="justify-content:left"><button id="btn-e3" onclick="toggleBox('btn-e3','box-e3')">Mostra ▼</button></div>
          <div id="box-e3" style="display:none;margin-top:8px">
            <div class="ok">
              <p><strong>Soluzione:</strong> Perché Windows usa CRLF (<span class="mono">\r\n</span>) e alcuni editor Linux si aspettano solo LF (<span class="mono">\n</span>). Inoltre l’encoding deve essere noto (meglio <strong>UTF-8</strong>).</p>
            </div>
          </div>
        </li>
      </ol>
    </div>

    <div class="inner-box">
      <h2>Takeaways</h2>
      <ul>
        <li>Un file è <strong>byte + regole</strong> (formato). Scegli regole chiare e documentate.</li>
        <li><strong>Testo</strong> = leggibile ma richiede parsing; <strong>binario</strong> = efficiente ma serve una specifica.</li>
        <li>Attenzione a <strong>path</strong>, <strong>permessi</strong>, <strong>buffering</strong>, <strong>newline</strong>, <strong>encoding</strong> (testo) ed <strong>endianness/versioni</strong> (binario).</li>
      </ul>
    </div>

  </div>

  <div class="nav-buttons">
    <button onclick="prevSlide()">&#8592; Indietro</button>
    <button onclick="nextSlide()">Avanti &#8594;</button>
  </div>
</div>

<script>
function toggleMenu(){ document.getElementById('menu').classList.toggle('open'); }
</script>
</body>
</html>
