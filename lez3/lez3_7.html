<!DOCTYPE html>
<html lang="it">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>4BIA – Lez3_7 · Indici per file binari (indice primario ordinato)</title>
  <link rel="stylesheet" href="../style.css">
  <link rel="stylesheet" href="../default.css">
  <script src="../highlight.js"></script>
  <script>try{hljs.highlightAll();}catch(e){}</script>
  <script>
    function prevSlide(){ window.location.href = "lez3_6.html"; }
    function nextSlide(){ window.location.href = "../programma.html"; }
    function toggleMenu(){ document.getElementById('menu').classList.toggle('open'); }
    function toggleBox(btnId, boxId){
      const box=document.getElementById(boxId), btn=document.getElementById(btnId);
      const open = box.style.display==='block';
      box.style.display = open ? 'none':'block';
      if(btn) btn.textContent = open ? 'Mostra ▼' : 'Nascondi ▲';
    }
  </script>
  <style>
    /* allineamento a sinistra nelle inner-box */
    .inner-box, .inner-box p, .inner-box ul, .inner-box ol, .inner-box li, .inner-box pre, .inner-box code {
      text-align: left !important;
    }
    .inner-box ul, .inner-box ol { margin: .5rem 0 .75rem 1rem; padding-left: 1.25rem; list-style-position: outside; }
    .inner-box li { margin: .25rem 0; }
    pre { white-space: pre; tab-size: 4; margin: 0 0 1rem 0; padding: .5rem .75rem; }

    /* box colorate */
    .note { background:#f7faff; border-left:4px solid #3b82f6; padding:.6rem .8rem; border-radius:8px }
    .ok   { background:#eefbf1; border-left:4px solid #22c55e; padding:.6rem .8rem; border-radius:8px; display:inline-block; margin-top:.25rem }
    .warn { background:#fff7ed; border-left:4px solid #f59e0b; padding:.6rem .8rem; border-radius:8px }

    /* ascii panel */
    .ascii { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace; background:#f8fafc; border:1px solid #e5e7eb; border-radius:8px; padding:.6rem .8rem; }
    .mini { font-size:.95rem; }

    table { width:100%; border-collapse: collapse; }
    th, td { border-bottom:1px solid #e5e7eb; padding:.45rem .5rem; vertical-align:top; text-align:left }
    th { background:#f8fafc }
  </style>
</head>
<body>
<!-- BEGIN MENU -->
<button class="menu-toggle" onclick="toggleMenu()">&#9776; Menu</button>
<div class="sidebar" id="menu">
  <h2>Lezione 3 — File I/O</h2>
  <ul>
    <li><a href="lez3_1.html">Lez3_1: Concetti di file</a></li>
    <li><a href="lez3_2.html">Lez3_2: File testuali (C++)</a></li>
    <li><a href="lez3_3.html">Lez3_3: File binari (base)</a></li>
    <li><a href="lez3_4.html">Lez3_4: Binari portabili (formati)</a></li>
    <li><a href="lez3_5.html">Lez3_5: fseek/ftell &amp; seekg/tellg</a></li>
    <li><a href="lez3_6.html">Lez3_6: Binario in C (esercizi)</a></li>
    <li><a href="lez3_7.html" class="active">Lez3_7: Indici per file binari</a></li>
  </ul>
</div>
<!-- END MENU -->

<div class="slide">
  <h1>Lez3_7 — Indici per file binari (indice primario ordinato)</h1>

  <div class="nav-buttons" style="margin-bottom:10px">
    <button onclick="prevSlide()">&#8592; Indietro</button>
    <button onclick="nextSlide()">Avanti &#8594;</button>
  </div>

  <div class="content-box">

    <div class="inner-box">
      <h2>Perché un indice</h2>
      <p class="note"><strong>Problema:</strong> cercare un record per chiave scorrendo tutto <code>data.bin</code> costa <strong>O(n)</strong> per ogni query.</p>
      <p class="ok"><strong>Idea:</strong> mantieni un <em>indice primario ordinato</em> di coppie <code>{chiave, offset}</code> → ricerca con <strong>binary search</strong> in <strong>O(log n)</strong>, poi <code>seek</code> diretto nel file dati.</p>
    </div>

    <div class="inner-box">
      <h2>Layout dei file (semplice &amp; robusto)</h2>
      <div class="ascii mini">
data.bin   : [HEADER][RECORD][RECORD]...[RECORD] <br/>
index.bin  : [HEADER][ (key:u32, offset:u64) ordinati per key ]
      </div>
      <ul class="mini">
        <li><strong>Header</strong>: magic, version, endianness, <code>record_size</code> (se fisso), <code>n_records</code>.</li>
        <li><strong>Tipi fissi</strong>: <code>uint32_t</code> per chiave (esempio), <code>uint64_t</code> per offset (file &gt; 2GB).</li>
        <li><strong>Endianness</strong> di formato definita (consigliato LE). I/O in <em>modalità binaria</em>.</li>
      </ul>
    </div>

    <div class="inner-box">
      <h2>Operazioni essenziali</h2>
      <ul>
        <li><strong>Build iniziale</strong>: scorri <code>data.bin</code>, raccogli <code>{key, offset}</code>, ordina, scrivi <code>index.bin</code>.</li>
        <li><strong>Search</strong> (puntuale): binary search su <code>index.bin</code> → ottieni <code>offset</code> → <code>seek</code> in <code>data.bin</code>.</li>
        <li><strong>Insert</strong> (record fisso): append in <code>data.bin</code>, poi aggiorna l’indice (in RAM) e riscrivi <code>index.bin</code> (per molte insert: <em>batch</em> o <em>rebuild</em>).</li>
        <li><strong>Update in-place</strong> (campo non-chiave): sovrascrivi a <code>offset</code>. Se cambia la chiave → rimuovi/riinserisci nell’indice.</li>
        <li><strong>Delete</strong>: cancellazione logica (tombstone/flag); compattazione periodica e rebuild dell’indice.</li>
      </ul>
    </div>

    <div class="inner-box">
      <h2>Pseudocodice — ricerca con indice ordinato</h2>
<pre><code>// INPUT: key cercata    OUTPUT: record logico o "non trovato"
idx = apri("index.bin", binario)   // carica in RAM o mappa l'array {key,offset}
(lo, hi) = (0, idx.n - 1)
while lo ≤ hi do
    mid = (lo + hi) // 2
    if key == idx[mid].key then
        off = idx[mid].offset
        dati = apri("data.bin", binario)
        seek(dati, off)          // posizionamento O(1)
        rec = leggi_record(dati)
        return rec
    else if key &lt; idx[mid].key then
        hi = mid - 1
    else
        lo = mid + 1
fine while
return "non trovato"
</code></pre>
      <p class="ok mini">Memoria indice ≈ <code>n * (sizeof(key) + sizeof(offset))</code> → ~12 B/record con <code>u32 + u64</code>.</p>
    </div>

    <!-- NEW: esempio numerico end-to-end -->
    <div class="inner-box">
      <h2>Esempio numerico end-to-end</h2>
      <p>Sia <code>index.bin</code> con 6 coppie ordinate per chiave:</p>
      <table class="mini">
        <tr><th>i</th><th>key</th><th>offset</th></tr>
        <tr><td>0</td><td>10</td><td>128</td></tr>
        <tr><td>1</td><td>14</td><td>256</td></tr>
        <tr><td>2</td><td>21</td><td>384</td></tr>
        <tr><td>3</td><td>37</td><td>512</td></tr>
        <tr><td>4</td><td>40</td><td>640</td></tr>
        <tr><td>5</td><td>55</td><td>768</td></tr>
      </table>
      <div class="ascii mini" style="margin-top:.5rem">
Ricerca di key=37:<br/>
lo=0, hi=5 → mid=2 (key=21)  → 37 &gt; 21 → lo=3<br/>
lo=3, hi=5 → mid=4 (key=40)  → 37 &lt; 40 → hi=3<br/>
lo=3, hi=3 → mid=3 (key=37)  → trovato! offset=512 → seek(data.bin, 512)
      </div>
      <p class="ok mini">Salto diretto nel file dati: lettura del record senza scorrere tutto il file.</p>
    </div>

    <!-- NEW: C++ mini-esempi build & lookup -->
    <div class="inner-box">
      <h2>Mini-esempi C++: build e lookup</h2>
      <div class="note mini">Formato didattico: little-endian, tipi fissi; header <code>"IDX\0"</code>, ver=1, n.</div>

      <h3>Build dell’indice (da <code>data.bin</code> a record fissi)</h3>
<pre><code class="language-cpp">#include &lt;fstream&gt;
#include &lt;cstdint&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

struct Pair { uint32_t key; uint64_t off; };

uint32_t read_key_from_record(std::ifstream&amp; data){
    // supponiamo che la chiave sia nei primi 4 byte del record
    uint32_t k=0; data.read((char*)&k, 4); return k;
}

void build_index(const char* dataPath, const char* idxPath, uint64_t record_size){
    std::ifstream data(dataPath, std::ios::binary);
    if(!data) throw std::runtime_error("open data");
    std::vector&lt;Pair&gt; idx;
    uint64_t off=0;
    while (true){
        data.seekg(off);
        uint32_t k=0;
        data.read((char*)&k, 4);
        if(!data) break;               // fine file
        idx.push_back({k, off});
        off += record_size;            // record fisso
    }
    std::sort(idx.begin(), idx.end(), [](auto&amp; a, auto&amp; b){ return a.key &lt; b.key; });

    std::ofstream out(idxPath, std::ios::binary);
    const char magic[4]={'I','D','X','\0'};
    uint32_t ver=1, n=(uint32_t)idx.size();
    out.write(magic,4); out.write((char*)&ver,4); out.write((char*)&n,4);
    out.write((char*)idx.data(), idx.size()*sizeof(Pair));
}
</code></pre>

      <h3>Lookup (ricerca binaria in RAM + seek nel file dati)</h3>
<pre><code class="language-cpp">#include &lt;optional&gt;

std::optional&lt;uint64_t&gt; load_and_find(const char* idxPath, uint32_t key){
    std::ifstream in(idxPath, std::ios::binary);
    if(!in) return std::nullopt;
    char magic[4]; uint32_t ver=0,n=0;
    in.read(magic,4); in.read((char*)&ver,4); in.read((char*)&n,4);
    if(std::string(magic,4)!="IDX\0" || ver!=1) return std::nullopt;
    std::vector&lt;Pair&gt; v(n);
    in.read((char*)v.data(), n*sizeof(Pair));
    // binary search
    int lo=0, hi=(int)v.size()-1;
    while(lo&lt;=hi){
        int mid=(lo+hi)/2;
        if      (key==v[mid].key) return v[mid].off;
        else if (key&lt; v[mid].key) hi=mid-1;
        else                      lo=mid+1;
    }
    return std::nullopt;
}

// Uso finale:
void retrieve_record(const char* dataPath, const char* idxPath, uint32_t key, uint64_t rec_size){
    auto off = load_and_find(idxPath, key);
    if(!off){ std::cout &lt;&lt; "non trovato\n"; return; }
    std::ifstream data(dataPath, std::ios::binary);
    data.seekg(*off);
    std::vector&lt;char&gt; rec(rec_size);
    data.read(rec.data(), rec_size);
    // ... decodifica campi del record ...
}
</code></pre>
      <p class="tip mini">Per indici grandi usa memory-mapping o ricerca binaria “on-disk” leggendo blocchi con <code>seekg</code> “a metà”.</p>
      <div class="tip mini">
        <p><strong>Micro-esercizi guidati</strong> (durata suggerita 10 minuti ciascuno):</p>
        <ul class="mini">
          <li><b>Fix mirato.</b> Scrivi una funzione che dato l&#8217;<code>id</code> e un nuovo valore aggiorni il record in <code>data.bin</code> usando l&#8217;indice per posizionarti; verifica il risultato con una seconda lettura diretta.</li>
          <li><b>Rebuild sicuro.</b> Implementa una <code>rebuild_index()</code> che scriva l&#8217;indice in un file temporaneo, chiami <code>flush</code>/<code>fsync</code> e poi esegua <code>rename()</code> per sostituire <code>index.bin</code> senza lasciare file corrotti.</li>
          <li><b>Audit dell&#8217;indice.</b> Confronta i record su disco con le coppie <code>{key, offset}</code>: scansiona <code>data.bin</code> e segnala eventuali chiavi mancanti o duplicati rispetto al vettore ordinato.</li>
        </ul>
      </div>
    </div>

    <div class="inner-box">
      <h2>Portabilità minima (da rispettare)</h2>
      <ul class="mini">
        <li><strong>Tipi a larghezza fissa</strong> (no <code>long/size_t</code> “raw” sul disco).</li>
        <li><strong>Endianness</strong> di formato costante e documentata.</li>
        <li><strong>Niente puntatori/bit-field</strong> nel file: solo dati logici.</li>
        <li><strong>Aggiornamenti atomici</strong> dell’indice: scrivi <code>index.tmp</code> → flush/fsync → rename.</li>
      </ul>
    </div>

    <div class="inner-box">
      <h2>Complexity snapshot</h2>
      <ul class="mini">
        <li><strong>Ricerca</strong>: O(log n) su <code>index.bin</code> + O(1) per <code>seek</code>.</li>
        <li><strong>Insert singola</strong>: O(n) su array ordinato (riscrittura). Per molte insert → <em>batch</em> o <em>rebuild</em>.</li>
        <li><strong>Didattica</strong>: inizia con record a lunghezza fissa; poi passa ai variabili (length-prefix) aggiornando gli offset.</li>
      </ul>
    </div>

    <!-- NEW: esercizio a comparsa -->
    <div class="inner-box">
      <h2>Esercizio (con soluzione a comparsa)</h2>
      <p><strong>E1 — Costruisci e usa un indice primario:</strong> dato <code>data.bin</code> con record fissi di 64 byte, chiave <code>u32</code> al byte 0, <br/>1) genera <code>index.bin</code> ordinando per chiave; 2) implementa una funzione che dato <code>key</code> stampa il record.</p>
      <div class="nav-buttons" style="justify-content:left"><button id="btn-e1" onclick="toggleBox('btn-e1','box-e1')">Mostra ▼</button></div>
      <div id="box-e1" style="display:none;margin-top:8px">
        <div class="ok mini">
          <p><strong>Soluzione (idea):</strong><br/>
          <em>Build:</em> scorri <code>data.bin</code> a passi di 64, leggi i 4 byte iniziali → vettore <code>{key, offset}</code> → ordina → scrivi header + vettore.<br/>
          <em>Lookup:</em> carica header e vettore → binary search → <code>seekg(offset)</code> in <code>data.bin</code> → leggi 64 byte → stampa campi.</p>
        </div>
      </div>
    </div>

  </div>

  <div class="nav-buttons">
    <button onclick="prevSlide()">&#8592; Indietro</button>
    <button onclick="nextSlide()">Avanti &#8594;</button>
  </div>
</div>

<script>
function toggleMenu(){ document.getElementById('menu').classList.toggle('open'); }
</script>
</body>
</html>
