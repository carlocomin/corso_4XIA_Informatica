<!DOCTYPE html>
<html lang="it">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>4BIA – Lez2.6 · Perché NON serializzare una struct “a crudo”</title>
  <link rel="stylesheet" href="../style.css">
  <link rel="stylesheet" href="../default.css">
  <script src="../highlight.js"></script>
  <script>try{hljs.highlightAll();}catch(e){}</script>
  <script>
    function prevSlide(){ window.location.href = "lez2_5.html"; }
    function nextSlide(){ window.location.href = "../lez3/lez3_1.html"; }
    function toggleMenu(){ document.getElementById('menu').classList.toggle('open'); }
    function toggleBox(btnId, boxId){
      const box = document.getElementById(boxId);
      const btn = document.getElementById(btnId);
      const open = box.style.display === 'block';
      box.style.display = open ? 'none' : 'block';
      if (btn) btn.textContent = open ? 'Mostra ▼' : 'Nascondi ▲';
    }
  </script>
  <!-- allineamento forte a sinistra + box evidenziati -->
  <style>
    .inner-box, .inner-box p, .inner-box ul, .inner-box ol, .inner-box li,
    .inner-box pre, .inner-box code, .content-box { text-align:left !important; }
    .inner-box ul, .inner-box ol, .content-box > ul, .content-box > ol {
      margin:.5rem 0 .75rem 1.1rem;
      padding-left:1.35rem;
      list-style-position:outside;
    }
    .inner-box li, .content-box > ul > li, .content-box > ol > li { margin:.25rem 0; }
    pre, pre code { text-align:left !important; white-space:pre; tab-size:4; margin:0 0 1rem 0; padding:.5rem .75rem; }

    .box  { background:var(--panel,#fff); border-radius:12px; padding:12px; box-shadow:0 2px 6px rgba(0,0,0,.08); margin-bottom:14px }
    .note { background:#f7faff; border-left:4px solid #3b82f6; padding:.6rem .8rem; border-radius:8px; margin:.35rem 0; }
    .warn { background:#fff7ed; border-left:4px solid #f59e0b; padding:.6rem .8rem; border-radius:8px; margin:.35rem 0; }
    .ok   { background:#eefbf1; border-left:4px solid #22c55e; padding:.6rem .8rem; border-radius:8px; margin:.35rem 0; display:inline-block; }
    .tip  { font-style:italic; opacity:.95 }
    ul.checklist li { margin:.35rem 0; }
  </style>
</head>
<body>
<!-- BEGIN MENU -->
<button class="menu-toggle" onclick="toggleMenu()">&#9776; Menu</button>
<div class="sidebar" id="menu">
  <h2>Lezione 2 — Struct (ripasso mirato)</h2>
  <ul>
    <li><a href="lez2_1.html">Lez2.1: Motivazione &amp; sintassi base</a></li>
    <li><a href="lez2_2.html">Lez2.2: Inizializzazioni in C/C++</a></li>
    <li><a href="lez2_3.html">Lez2.3: Passaggio a funzione</a></li>
    <li><a href="lez2_4.html">Lez2.4: Collezioni di struct &amp; lambda</a></li>
    <li><a href="lez2_5.html">Lez2.5: Layout, sizeof, padding &amp; align</a></li>
    <li><a href="lez2_6.html" class="active">Lez2.6: Serializzare le struct in modo sicuro</a></li>
  </ul>
</div>
<!-- END MENU -->

<div class="slide">
  <h1>Lez2.6 — Perché <em>non conviene</em> salvare una <code>struct</code> “a crudo”</h1>

  <div class="nav-buttons" style="margin-bottom:10px">
    <button onclick="prevSlide()">&#8592; Indietro</button>
    <button onclick="nextSlide()">Avanti &#8594;</button>
  </div>

  <div class="content-box">

    <div class="inner-box box">
      <h2>Obiettivo della lezione</h2>
      <p>
        Tentazione classica: «Ho una <code>struct</code>. Chiamo <code>fwrite(&amp;s, sizeof s, 1, f)</code> e ho finito».
        Il problema è che quel blocco di memoria <strong>non descrive</strong> il contenuto in modo stabile: dipende dalla
        piattaforma, dal compilatore e persino dalle opzioni di build.
      </p>
      <p class="ok"><strong>Idea guida:</strong> vogliamo file che restano leggibili nel tempo e su PC diversi. Per riuscirci
        serve un <em>formato esplicito</em>: scriviamo ogni campo con tipo, ordine ed endianness ben definiti.</p>
    </div>

    <div class="inner-box">
      <h2>Glossario minimo</h2>
      <ul>
        <li><strong>Allineamento</strong>: alcuni tipi (ad esempio <code>int</code>, <code>double</code>) devono iniziare a indirizzi multipli di 2/4/8 byte. La regola è fissata da CPU + ABI.</li>
        <li><strong>Padding</strong>: byte “cuscinetto” inseriti automaticamente dal compilatore per rispettare l’allineamento.</li>
        <li><strong>Endianness</strong>: ordine con cui i byte di un numero multi-byte sono memorizzati. Può essere little-endian o big-endian.</li>
        <li><strong>ABI</strong> (Application Binary Interface): stabilisce dimensione dei tipi, allineamenti, convenzioni di chiamata… Cambia ABI ⇒ cambia il layout in memoria.</li>
      </ul>
    </div>

    <div class="inner-box box">
      <h2>1) Padding &amp; allineamento: perché sono pericolosi su disco</h2>
      <p>
        Quando scrivi l’intera struct con un’unica <code>fwrite</code> ottieni anche i byte di padding.
        Il numero e la posizione di quei byte dipendono dall’ABI e possono cambiare fra compilatori o versioni diverse.
      </p>
<pre><code class="language-cpp">struct A { char c; int x; };
// Spesso: sizeof(A) == 8 (non 5) a causa del padding</code></pre>
      <ul>
        <li>Su un’ABI un campo può iniziare a offset 4, su un’altra a offset 2 ⇒ i file diventano incompatibili.</li>
        <li>Ricompilare con ottimizzazioni diverse può cambiare il layout, rompendo i file già salvati.</li>
      </ul>
      <p class="warn"><strong>Conclusione:</strong> il layout “in memoria” non è un buon formato “su disco”.</p>
    </div>

    <div class="inner-box box">
      <h2>2) Padding non inizializzato: rischi concreti</h2>
      <ul>
        <li>I byte di padding possono contenere <em>dati residui</em>: scrivendoli su file potresti leakare informazioni sensibili.</li>
        <li>Due struct con campi identici possono avere byte di padding diversi ⇒ il confronto <code>memcmp</code> fallisce.</li>
      </ul>
    </div>

    <div class="inner-box box">
      <h2>3) Endianness &amp; rappresentazione dei tipi</h2>
      <ul>
        <li>Gli interi multi-byte dipendono dall’endian della CPU: se non converti, i byte risultano invertiti su macchine diverse.</li>
        <li>I <code>float</code>/<code>double</code> sono quasi sempre IEEE-754, ma l’ordine dei byte non è garantito.</li>
      </ul>
      <p class="ok"><strong>Esempio:</strong> <code>uint16_t v = 0x1234;</code> ⇒ su little-endian il file contiene <code>34 12</code>, su big-endian <code>12 34</code>.</p>
    </div>

    <div class="inner-box box">
      <h2>4) Dimensioni dei tipi non uniformi</h2>
      <p>
        Tipi come <code>long</code>, <code>size_t</code>, <code>wchar_t</code> o gli <code>enum</code> dipendono dalla piattaforma.
        Scriverli “a crudo” significa legarsi per sempre a quella configurazione.
      </p>
      <p class="warn"><strong>Esempio reale:</strong> su Windows 64 bit (modello LLP64) <code>long</code> occupa 32 bit; su Linux/macOS 64 bit (modello LP64) <code>long</code> è 64 bit.</p>
    </div>

    <div class="inner-box box">
      <h2>5) Bit-field: layout deciso dall’implementazione</h2>
      <p>
        Due compilatori possono impacchettare gli stessi bit-field in modo diverso. Se scrivi i byte risultanti, un altro
        programma non saprà come interpretarli. Meglio codificare i campi come interi e gestire i bit manualmente.
      </p>
    </div>

    <div class="inner-box box">
      <h2>6) (C++) Oggetti “non banali”</h2>
      <ul>
        <li>Classi con <em>virtual</em> (vtable) o ereditarietà implicano puntatori nascosti: il dump binario sarebbe inutile.</li>
        <li>Membri non <code>trivially copyable</code> (<code>std::string</code>, <code>std::vector</code>…) contengono puntatori verso dati dinamici: sul file salveresti solo indirizzi invalidi.</li>
      </ul>
      <p class="warn">Perfino con tipi banali: basta riordinare un campo o aggiungerne uno nuovo per rompere la compatibilità.</p>
    </div>

    <div class="inner-box box">
      <h2>7) Sicurezza &amp; manutenzione</h2>
      <ul>
        <li>Scrivere memoria grezza può esporre dati sensibili, inclusi indirizzi o frammenti di heap.</li>
        <li>Un cambio di compilatore, di flag o persino di versione della libreria standard può invalidare tutti i file salvati.</li>
      </ul>
    </div>

    <div class="inner-box box">
      <h2>8) «<code>#pragma pack</code>» non risolve il problema</h2>
      <ul>
        <li>Forza un layout compatto, ma la sintassi cambia fra compilatori e non risolve endianness o dimensioni dei tipi.</li>
        <li>Può generare accessi disallineati: su alcune CPU sono lenti, su altre causano eccezioni hardware.</li>
      </ul>
      <p class="tip">Se devi imitare un layout imposto (protocollo esterno), tratta quei record come <em>blob</em> di byte e accedi ai campi con funzioni dedicate, non dereferenziare direttamente.</p>
    </div>

    <div class="inner-box">
      <h2><em>Mai</em> scrivere “raw”?</h2>
      <p>
        Eccezione ammessa: cache temporanee usate solo dalla <strong>stessa build</strong> sul <strong>medesimo PC</strong>.
        Anche in quel caso bisogna imporre qualche regola di sicurezza.
      </p>
      <ul>
        <li>Inserisci un header con <strong>magic</strong>, <strong>versione</strong>, <strong>sizeof(T)</strong> e magari un checksum.</li>
        <li>Limita i tipi a quelli <em>banali</em> (<code>std::is_trivially_copyable_v&lt;T&gt;</code> in C++).</li>
        <li>Azzera la struct prima di riempirla per non scrivere padding non inizializzato.</li>
      </ul>
    </div>

    <div class="inner-box">
      <h2>La strada giusta: <em>formato esplicito</em> campo per campo</h2>

      <div class="box">
        <h3>Regole pratiche per file portabili</h3>
        <ul>
          <li>Definisci e documenta l’<strong>ordine dei campi</strong> nel file.</li>
          <li>Usa <strong>tipi a larghezza fissa</strong> (es. <code>uint32_t</code>, <code>int16_t</code>) disponibili in <code>&lt;cstdint&gt;</code>/<code>&lt;stdint.h&gt;</code>.</li>
          <li>Stabilisci un’<strong>endianness di formato</strong> (spesso big-endian “network order”) e converti sia in scrittura che in lettura.</li>
          <li>Apri i file in <strong>modalità binaria</strong> (<code>"wb"</code>, <code>"rb"</code>) per evitare modifiche automatiche alle newline su Windows.</li>
        </ul>
      </div>

      <div class="box">
        <h3>C (funzioni d’aiuto per interi a 32 bit big-endian)</h3>
<pre><code class="language-c">#include &lt;stdint.h&gt;
#include &lt;stdio.h&gt;

static inline uint32_t to_be32(uint32_t x) {
#if defined(__BYTE_ORDER__) && __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
    return __builtin_bswap32(x);
#else
    return x;
#endif
}

void write_u32_be(FILE* f, uint32_t v) {
    uint32_t be = to_be32(v);
    fwrite(&be, 1, 4, f);
}

uint32_t read_u32_be(FILE* f) {
    uint32_t be;
    fread(&be, 1, 4, f);
#if defined(__BYTE_ORDER__) && __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
    return __builtin_bswap32(be);
#else
    return be;
#endif
}</code></pre>
      </div>

      <div class="box">
        <h3>C++23 (conversione endianness generica)</h3>
<pre><code class="language-cpp">#include &lt;bit&gt;
#include &lt;cstdint&gt;
#include &lt;concepts&gt;

template &lt;std::unsigned_integral T&gt;
T to_be(T x) {
    if constexpr (std::endian::native == std::endian::little)
        return std::byteswap(x);
    else
        return x;
}</code></pre>
        <p class="note"><strong>Se non hai C++23</strong>, usa routine come in C (bswap) o librerie/utility equivalenti.</p>
      </div>

      <div class="box">
        <h3>Evita puntatori e bit-field nel formato</h3>
        <p>
          Per le stringhe scrivi prima la <strong>lunghezza</strong> (in byte o in caratteri) e poi i dati.
          Per record di lunghezza variabile usa una struttura TLV (Type-Length-Value) o un piccolo <strong>header</strong>
          con magic, versione e conteggi.
        </p>
      </div>
    </div>

    <div class="inner-box">
      <h2>Esempio “prima/dopo”</h2>
      <div class="box">
        <h3>❌ Sconsigliato (dump “raw”)</h3>
<pre><code class="language-cpp">struct Rec { char tag; int value; };
fwrite(&amp;rec, sizeof rec, 1, f); // dipende da padding, endianness, ABI: NON portabile</code></pre>
      </div>
      <div class="box">
        <h3>✅ Consigliato (formato esplicito)</h3>
<pre><code class="language-c">// Formato: tag (1 byte), value (u32 big-endian)
fputc(rec.tag, f);
write_u32_be(f, (uint32_t)rec.value);

// Lettura
rec.tag   = fgetc(f);
rec.value = (int)read_u32_be(f);</code></pre>
        <p class="ok">Ora il file è stabile: qualsiasi lettore che rispetta le stesse regole rilegge i dati corretti.</p>
      </div>
    </div>

    <div class="inner-box box">
      <h2>Checklist rapida (prima di scrivere su file)</h2>
      <ul class="checklist">
        <li>[ ] Tipi a larghezza fissa (<code>uint32_t</code>, …)</li>
        <li>[ ] Endianness di formato decisa (spesso big-endian)</li>
        <li>[ ] Evita puntatori e bit-field nel formato</li>
        <li>[ ] Non usare <code>long</code>/<code>size_t</code>/<code>bool</code> senza specificare la dimensione</li>
        <li>[ ] Header con magic + versione (+ checksum se utile)</li>
        <li>[ ] File in modalità <strong>binaria</strong> (<code>"wb"</code>/<code>"rb"</code>)</li>
        <li>[ ] In C++ confronta i <strong>campi</strong>, non i byte (niente <code>memcmp</code> sulle struct)</li>
      </ul>
    </div>

    <div class="inner-box">
      <h2>Esercizi rapidi</h2>
      <ol>
        <li><strong>E1 — Individua i rischi</strong><br/>
          <em>Testo:</em> Hai <code>struct A{char c; int x;}</code>. Spiega perché <code>fwrite(&amp;a, sizeof a, 1, f)</code> non è portabile e cosa succede cambiando compilatore/ABI.
          <div class="nav-buttons" style="justify-content:left"><button id="btn-e1" onclick="toggleBox('btn-e1','box-e1')">Mostra ▼</button></div>
          <div id="box-e1" style="display:none;margin-top:8px">
            <p class="note">Il padding inserito per allineare <code>x</code> viene scritto sul file ma cambia da ABI ad ABI. Un’altra build può avere un <code>sizeof(A)</code> diverso e leggere byte sfasati ⇒ file incompatibile.</p>
          </div>
        </li>
        <li><strong>E2 — Riscrivi in formato esplicito</strong><br/>
          <em>Testo:</em> Per <code>struct Rec{char tag; int value;}</code> descrivi una strategia di salvataggio/lettura portabile.
          <div class="nav-buttons" style="justify-content:left"><button id="btn-e2" onclick="toggleBox('btn-e2','box-e2')">Mostra ▼</button></div>
          <div id="box-e2" style="display:none;margin-top:8px">
<pre><code class="language-text">Scrivi: 1) tag (1 byte), 2) value come uint32_t in big-endian (con bswap se serve).
Leggi: 1) tag, 2) leggi 4 byte e riconverti da big-endian a host.</code></pre>
          </div>
        </li>
      </ol>
    </div>

  </div>

  <div class="nav-buttons">
    <button onclick="prevSlide()">&#8592; Indietro</button>
    <button onclick="nextSlide()">Avanti &#8594;</button>
  </div>
</div>

<script>
function toggleMenu(){ document.getElementById('menu').classList.toggle('open'); }
</script>
</body>
</html>
