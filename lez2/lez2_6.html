<!DOCTYPE html>
<html lang="it">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>4BIA – Lez3_5 · Perché NON serializzare una struct “a crudo”</title>
  <link rel="stylesheet" href="../style.css">
  <link rel="stylesheet" href="../default.css">
  <script src="../highlight.js"></script>
  <script>try{hljs.highlightAll();}catch(e){}</script>
  <script>
    function prevSlide(){ window.location.href = "lez3_4.html"; }
    function nextSlide(){ window.location.href = "lez3_6.html"; }
    function toggleMenu(){ document.getElementById('menu').classList.toggle('open'); }
    function toggleBox(btnId, boxId){
      const box = document.getElementById(boxId);
      const btn = document.getElementById(btnId);
      const open = box.style.display === 'block';
      box.style.display = open ? 'none' : 'block';
      if (btn) btn.textContent = open ? 'Mostra ▼' : 'Nascondi ▲';
    }
  </script>
  <!-- allineamento forte a sinistra + box evidenziati -->
  <style>
    .inner-box, .inner-box p, .inner-box ul, .inner-box ol, .inner-box li,
    .inner-box pre, .inner-box code, .content-box { text-align:left !important; }
    .inner-box ul, .inner-box ol { margin:.5rem 0 .75rem 1rem; padding-left:1.25rem; list-style-position:outside; }
    .inner-box li { margin:.25rem 0; }
    pre, pre code { text-align:left !important; white-space:pre; tab-size:4; margin:0 0 1rem 0; padding:.5rem .75rem; }

    .box  { background:var(--panel,#fff); border-radius:12px; padding:12px; box-shadow:0 2px 6px rgba(0,0,0,.08); margin-bottom:14px }
    .note { background:#f7faff; border-left:4px solid #3b82f6; padding:.6rem .8rem; border-radius:8px; margin:.35rem 0; }
    .warn { background:#fff7ed; border-left:4px solid #f59e0b; padding:.6rem .8rem; border-radius:8px; margin:.35rem 0; }
    .ok   { background:#eefbf1; border-left:4px solid #22c55e; padding:.6rem .8rem; border-radius:8px; margin:.35rem 0; display:inline-block; }
    .tip  { font-style:italic; opacity:.95 }
    ul.checklist li { margin:.35rem 0; }
  </style>
</head>
<body>
<!-- BEGIN MENU -->
<button class="menu-toggle" onclick="toggleMenu()">&#9776; Menu</button>
<div class="sidebar" id="menu">
  <h2>Lezione 3 — File I/O</h2>
  <ul>
    <li><a href="lez3_1.html">Lez3_1: Concetti di file</a></li>
    <li><a href="lez3_2.html">Lez3_2: File testuali (C++)</a></li>
    <li><a href="lez3_3.html">Lez3_3: File binari (base)</a></li>
    <li><a href="lez3_4.html">Lez3_4: Binari portabili (formati)</a></li>
    <li><a href="lez3_5.html" class="active">Lez3_5: Perché NON scrivere struct “raw”</a></li>
    <li><a href="lez3_6.html">Lez3_6: Binario in C (esercizi)</a></li>
    <li><a href="lez3_7.html">Lez3_7: Indici per file binari</a></li>
    <li><a href="lez3_seek.html">Extra: Cursore &amp; posizionamento</a></li>
  </ul>
</div>
<!-- END MENU -->

<div class="slide">
  <h1>Perché <em>non conviene</em> scrivere/leggere una <code>struct</code> “a crudo”</h1>

  <div class="nav-buttons" style="margin-bottom:10px">
    <button onclick="prevSlide()">&#8592; Indietro</button>
    <button onclick="nextSlide()">Avanti &#8594;</button>
  </div>

  <div class="content-box">

    <div class="inner-box box">
      <h2>Obiettivo della lezione</h2>
      <p>
        A volte si pensa: “Ho una <code>struct</code>. La salvo su file con un colpo solo usando
        <code>fwrite(&amp;s, sizeof s, 1, f)</code> e poi la rileggo uguale”. <b>Sembra comodo</b>, ma è
        <b>fragile e non portabile</b>. In questa lezione capiamo <em>perché</em> e <em>come</em> farlo nel modo giusto.
      </p>
      <p class="ok"><b>Idea chiave:</b> su disco vogliamo un <strong>formato stabile</strong> (uguale su PC diversi e in anni diversi). Per ottenerlo, scriviamo i <em>campi</em> uno alla volta con regole precise.</p>
    </div>

    <div class="inner-box">
      <h2>Glossario</h2>
      <ul>
        <li><b>Allineamento</b>: alcuni tipi (es. <code>int</code>, <code>double</code>) vogliono partire a indirizzi multipli di 2/4/8 byte. È una regola della CPU/ABI.</li>
        <li><b>Padding</b>: byte “di riempimento” inseriti dal compilatore per rispettare l’allineamento.</li>
        <li><b>Endianness</b>: ordine dei byte di un numero (little-endian ↔ big-endian). Computer diversi possono usare ordini diversi.</li>
        <li><b>ABI</b>: insieme di regole della piattaforma (dimensione dei tipi, allineamenti, convenzioni...). Cambiando ABI, può cambiare il layout in memoria.</li>
      </ul>
    </div>

    <div class="inner-box box">
      <h2>1) Padding &amp; allineamento: perché sono un problema</h2>
      <p>Il compilatore può inserire byte “cuscinetto” tra i campi. Quei byte finiscono <b>nel file</b> se salvi la struct a blocchi.</p>
<pre><code class="language-cpp">struct A { char c; int x; };
// Spesso: sizeof(A) == 8 (non 5) a causa del padding</code></pre>
      <ul>
        <li>La quantità e la posizione del padding dipendono da compilatore/ABI/opzioni e possono cambiare nel tempo.</li>
        <li>Il file scritto oggi potrebbe non essere leggibile domani da una build diversa.</li>
      </ul>
      <p class="warn"><b>Conclusione:</b> il layout “in memoria” non è un buon formato “su disco”.</p>
    </div>

    <div class="inner-box box">
      <h2>2) Padding non inizializzato: rischi pratici</h2>
      <ul>
        <li>Il padding può contenere <em>spazzatura</em> (byte casuali) → rischi di <b>leak</b> di informazioni.</li>
        <li>Due struct “uguali” per campi possono essere diverse byte-a-byte → <code>memcmp</code> inaffidabile.</li>
      </ul>
    </div>

    <div class="inner-box box">
      <h2>3) Endianness &amp; rappresentazione dei tipi</h2>
      <ul>
        <li>Gli interi multi-byte dipendono dall’endian del PC: i byte possono risultare invertiti su un’altra macchina.</li>
        <li>I <code>float/double</code> di solito sono IEEE-754, ma l’ordine dei byte può comunque cambiare.</li>
      </ul>
      <p class="ok"><b>Esempio:</b> <code>uint16_t v = 0x1234;</code> → su little-endian il file contiene <code>34 12</code>, su big-endian <code>12 34</code>.</p>
    </div>

    <div class="inner-box box">
      <h2>4) Dimensioni dei tipi non uniformi</h2>
      <p>Tipi come <code>long</code>, <code>size_t</code>, <code>wchar_t</code>, <code>enum</code>… non hanno la stessa dimensione ovunque.</p>
      <p class="warn"><b>Esempio reale:</b> su Windows 64-bit (<em>LLP64</em>) <code>long</code> è 32 bit; su Linux/macOS 64-bit (<em>LP64</em>) <code>long</code> è 64 bit.</p>
    </div>

    <div class="inner-box box">
      <h2>5) Bit-field: il packing è “a scelta” dell’implementazione</h2>
      <p>Stesse dichiarazioni possono diventare byte su disco diversi a seconda del compilatore/ABI. Evita di salvarli “raw”.</p>
    </div>

    <div class="inner-box box">
      <h2>6) (C++) Oggetti “non banali”</h2>
      <ul>
        <li>Classi con <em>virtual</em> (vtable) o ereditarietà: <b>no</b> alla scrittura “raw”.</li>
        <li>Membri non trivially copyable (<code>std::string</code>, <code>std::vector</code>…): salveresti puntatori interni, non i dati veri.</li>
      </ul>
      <p class="warn">Anche per tipi banali: cambiare l’ordine/numero dei campi rompe la compatibilità binaria.</p>
    </div>

    <div class="inner-box box">
      <h2>7) Sicurezza &amp; manutenzione</h2>
      <ul>
        <li>Possibile esposizione involontaria di byte di memoria (padding, puntatori).</li>
        <li>Basta una ricompilazione con altre opzioni per <b>rompere</b> il formato “raw”.</li>
      </ul>
    </div>

    <div class="inner-box box">
      <h2>8) “<code>#pragma pack</code>” non è la soluzione</h2>
      <ul>
        <li>Riduce il padding ma è <b>non portabile</b> (diverso tra compilatori) e non risolve l’endianness.</li>
        <li>Può causare accessi disallineati (lenti o addirittura non validi su alcune CPU).</li>
      </ul>
      <p class="tip">Usalo solo quando devi rispettare un layout “imposto” e tratta quei record come <em>blob</em> di byte, non come oggetti da dereferenziare.</p>
    </div>

    <div class="inner-box">
      <h2><em>Mai</em> scrivere “raw”?</h2>
      <p>Solo per cache temporanee locali, lette e scritte dalla <b>stessa build</b> sulla <b>stessa macchina</b>. Anche lì:</p>
      <ul>
        <li>Metti un header con <b>magic</b>, <b>versione</b>, <b>sizeof(T)</b>, checksum.</li>
        <li>Limita i tipi a quelli <em>banali</em> (<code>std::is_trivially_copyable_v&lt;T&gt;</code> in C++).</li>
        <li>Azzera la struct prima di riempirla (per non scrivere padding “sporco”).</li>
      </ul>
    </div>

    <div class="inner-box">
      <h2>La strada giusta: <em>formato esplicito</em> campo-per-campo</h2>

      <div class="box">
        <h3>Regole semplici (portabili)</h3>
        <ul>
          <li>Scrivi i campi in un <b>ordine documentato</b> e sempre uguale.</li>
          <li>Usa <b>tipi a larghezza fissa</b> (<code>uint32_t</code>, <code>int16_t</code>, …).</li>
          <li>Scegli un’<b>endianness di formato</b> (spesso big-endian “network order”) e converti in scrittura/lettura.</li>
          <li>Apri i file in <b>modalità binaria</b> (<code>"wb"</code>, <code>"rb"</code>) per evitare la traduzione delle newline su Windows.</li>
        </ul>
      </div>

      <div class="box">
        <h3>C (funzioni d’aiuto per interi a 32 bit big-endian)</h3>
<pre><code class="language-c">#include &lt;stdint.h&gt;
#include &lt;stdio.h&gt;

static inline uint32_t to_be32(uint32_t x) {
#if defined(__BYTE_ORDER__) && __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
    return __builtin_bswap32(x);
#else
    return x;
#endif
}

void write_u32_be(FILE* f, uint32_t v) {
    uint32_t be = to_be32(v);
    fwrite(&be, 1, 4, f);
}

uint32_t read_u32_be(FILE* f) {
    uint32_t be;
    fread(&be, 1, 4, f);
#if defined(__BYTE_ORDER__) && __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
    return __builtin_bswap32(be);
#else
    return be;
#endif
}</code></pre>
      </div>

      <div class="box">
        <h3>C++23 (conversione endianness generica)</h3>
<pre><code class="language-cpp">#include &lt;bit&gt;
#include &lt;cstdint&gt;
#include &lt;concepts&gt;

template &lt;std::unsigned_integral T&gt;
T to_be(T x) {
    if constexpr (std::endian::native == std::endian::little)
        return std::byteswap(x);
    else
        return x;
}</code></pre>
        <p class="note"><b>Se non hai C++23</b>, usa routine come in C (bswap) o librerie/utility equivalenti.</p>
      </div>

      <div class="box">
        <h3>Evita puntatori e bit-field nel formato</h3>
        <p>Per stringhe salva <b>prima la lunghezza</b>, poi i caratteri. Per record variabili usa blocchi “TLV” (Type-Length-Value) o un piccolo <b>header</b> con <i>magic</i>, versione e conteggi.</p>
      </div>
    </div>

    <div class="inner-box">
      <h2>Esempio “prima/dopo” (chiaro e concreto)</h2>
      <div class="box">
        <h3>❌ Sconsigliato (dump “raw”)</h3>
<pre><code class="language-cpp">struct Rec { char tag; int value; };
fwrite(&rec, sizeof rec, 1, f); // dipende da padding, endianness, ABI: NON portabile</code></pre>
      </div>
      <div class="box">
        <h3>✅ Consigliato (formato esplicito)</h3>
<pre><code class="language-c">// Formato: tag (1 byte), value (u32 big-endian)
fputc(rec.tag, f);
write_u32_be(f, (uint32_t)rec.value);

// Lettura
rec.tag   = fgetc(f);
rec.value = (int)read_u32_be(f);</code></pre>
        <p class="ok">Ora il file è stabile: qualsiasi lettore che rispetta le stesse regole rilegge i dati corretti.</p>
      </div>
    </div>

    <div class="inner-box box">
      <h2>Checklist rapida (prima di scrivere su file)</h2>
      <ul class="checklist">
        <li>[ ] Tipi a larghezza fissa (<code>uint32_t</code>, …)</li>
        <li>[ ] Endianness di formato decisa (spesso big-endian)</li>
        <li>[ ] Niente puntatori/bit-field nel formato</li>
        <li>[ ] Evita <code>long</code>/<code>size_t</code>/<code>bool</code> “raw”</li>
        <li>[ ] Header con magic + versione (+ checksum se utile)</li>
        <li>[ ] File in modalità <b>binaria</b> (<code>"wb"</code>/<code>"rb"</code>)</li>
        <li>[ ] In C++ confronta i <b>campi</b>, non i byte (niente <code>memcmp</code> sulle struct)</li>
      </ul>
    </div>

    <!-- Esercizi brevi con soluzione a comparsa -->
    <div class="inner-box">
      <h2>Esercizi (brevi, mirati)</h2>
      <ol>
        <li><b>E1 — Individua i rischi</b><br/>
          <em>Testo:</em> Hai <code>struct A{char c; int x;}</code>. Spiega perché <code>fwrite(&amp;a,sizeof a,1,f)</code> non è portabile e cosa succede cambiando compilatore/ABI.
          <div class="nav-buttons" style="justify-content:left"><button id="btn-e1" onclick="toggleBox('btn-e1','box-e1')">Mostra ▼</button></div>
          <div id="box-e1" style="display:none;margin-top:8px">
            <p class="note">Per via del <b>padding</b> e dell’<b>allineamento</b> <code>sizeof(A)</code> include byte non “logici”. Cambiando compilatore/ABI cambia il layout → il file diventa incompatibile.</p>
          </div>
        </li>
        <li><b>E2 — Riscrivi in formato esplicito</b><br/>
          <em>Testo:</em> Per <code>struct Rec{char tag; int value;}</code> scrivi la strategia di salvataggio/lettura portabile.
          <div class="nav-buttons" style="justify-content:left"><button id="btn-e2" onclick="toggleBox('btn-e2','box-e2')">Mostra ▼</button></div>
          <div id="box-e2" style="display:none;margin-top:8px">
<pre><code class="language-text">Scrivi: 1) tag (1 byte), 2) value come uint32_t in big-endian (con bswap se serve).
Leggi: 1) tag, 2) leggi 4 byte e riconverti da big-endian a host.</code></pre>
          </div>
        </li>
      </ol>
    </div>

  </div>

  <div class="nav-buttons">
    <button onclick="prevSlide()">&#8592; Indietro</button>
    <button onclick="nextSlide()">Avanti &#8594;</button>
  </div>
</div>

<script>
function toggleMenu(){ document.getElementById('menu').classList.toggle('open'); }
</script>
</body>
</html>
