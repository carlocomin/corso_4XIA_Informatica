<!DOCTYPE html>
<html lang="it">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>4BIA – Lez2.4 · Collezioni di struct & lambda (sort, find, filter)</title>
  <link rel="stylesheet" href="../style.css">
  <link rel="stylesheet" href="../default.css">
  <script src="../highlight.js"></script>
  <script>try{hljs.highlightAll();}catch(e){}</script>
  <script>
    function prevSlide(){ window.location.href = "lez2_3.html"; }
    function nextSlide(){ window.location.href = "lez2_5.html"; } // placeholder eventuale
    function toggleMenu(){ document.getElementById('menu').classList.toggle('open'); }
    function toggleBox(btnId, boxId){
      const box = document.getElementById(boxId);
      const btn = document.getElementById(btnId);
      const open = box.style.display === 'block';
      box.style.display = open ? 'none' : 'block';
      if (btn) btn.textContent = open ? 'Mostra ▼' : 'Nascondi ▲';
    }
  </script>
  <style>
    .box  { background:var(--panel,#fff); border-radius:12px; padding:12px; box-shadow:0 2px 6px rgba(0,0,0,.08); margin-bottom:14px }
    .note { background:#f7faff; border-left:4px solid #3b82f6; padding:.6rem .8rem; border-radius:8px }
    .warn { background:#fff7ed; border-left:4px solid #f59e0b; padding:.6rem .8rem; border-radius:8px }
    .ok   { background:#eefbf1; border-left:4px solid #22c55e; padding:.6rem .8rem; border-radius:8px; display:inline-block }
    .tip  { font-style: italic; opacity:.9 }
    /* Hard-left per testi/elenco/codice */
    .inner-box, .inner-box p, .inner-box ul, .inner-box li, .inner-box h3 { text-align:left !important; }
    .inner-box ul { margin:.5rem 0 .75rem 1rem; padding-left:1.25rem; list-style-position:outside }
    .inner-box li { margin:.25rem 0 }
    .box ul { margin:.5rem 0 .75rem 1rem; padding-left:1.25rem; list-style-position:outside }
    .box li { margin:.25rem 0 }
    pre, pre code, .inner-box pre, .inner-box pre code, .box pre, .box pre code { text-align:left !important; white-space:pre; tab-size:4; margin:0 0 1rem 0; padding:.5rem .75rem; }
  </style>
</head>
<body>
<!-- BEGIN MENU -->
<button class="menu-toggle" onclick="toggleMenu()">&#9776; Menu</button>
<div class="sidebar" id="menu">
  <h2>Lezione 2 — Struct (ripasso mirato)</h2>
  <ul>
    <li><a href="lez2_1.html">Lez2.1: Motivazione &amp; sintassi base</a></li>
    <li><a href="lez2_2.html">Lez2.2: Inizializzazioni in C/C++</a></li>
    <li><a href="lez2_3.html">Lez2.3: Passaggio a funzione</a></li>
    <li><a href="lez2_4.html" class="active">Lez2.4: Collezioni di struct &amp; lambda</a></li>
  </ul>
</div>
<!-- END MENU -->

<div class="slide">
  <h1>Lez2.4 — Collezioni di struct & funzioni <em>lambda</em> (C++ → C)</h1>

  <div class="nav-buttons" style="margin-bottom:10px">
    <button onclick="prevSlide()">&#8592; Indietro</button>
    <button onclick="nextSlide()">Avanti &#8594;</button>
  </div>

  <div class="content-box">

    <div class="inner-box">
      <h2>Obiettivi</h2>
      <ul>
        <li>Gestire collezioni di record con <code>std::vector&lt;T&gt;</code> (aggiunta, iterazione, modifica, filtri, aggregazioni).</li>
        <li>Capire cos’è una <strong>lambda</strong>, la sua sintassi (catture/parametri/ritorno) e perché è utile.</li>
        <li>Usare <code>sort</code>, <code>find_if</code>, <code>count_if</code>, <code>copy_if</code>, <code>erase_remove_if</code> con lambda.</li>
        <li>Vedere l’equivalente in C: array di struct + <code>qsort</code> con funzione di confronto.</li>
      </ul>
      <p class="note"><b>Perché <code>std::vector</code>?</b> Memoria contigua (cache-friendly), dimensione dinamica, ricco set di algoritmi della STL. È la scelta naturale per insiemi di record.</p>
    </div>

    <!-- C++: vector di struct -->
    <div class="box">
      <h2>C++ — Collezioni di struct con <code>std::vector</code></h2>
<pre><code class="language-cpp">#include &lt;string&gt;
#include &lt;vector&gt;

struct Studente {
    std::string nome, cognome;
    int eta = 0;
    double media = 0.0;
};

int main() {
    std::vector&lt;Studente&gt; classe{
        {"Ada","Lovelace",17,9.4},
        {"Alan","Turing",18,10.0},
        {"Edsger","Dijkstra",19,9.1}
    };

    // Aggiunte
    classe.push_back({"Grace","Hopper",20,8.8});          // copia/move di un temporaneo
    classe.emplace_back("Barbara","Liskov",20,9.2);       // costruzione in-place

    // Iterazione: lettura vs modifica
    for (const auto&amp; s : classe) { /* sola lettura, nessuna copia */ }
    for (auto&amp; s : classe) { /* modifica in-place di s */ }
}
</code></pre>
      <ul>
        <li><b>push_back</b>: inserisce una copia/move di un oggetto già costruito.</li>
        <li><b>emplace_back</b>: costruisce l’oggetto direttamente “dentro” il vector (evita una costruzione superflua).</li>
      </ul>
    </div>

    <!-- Lambda: spiegazione -->
    <div class="box">
      <h2>C++ — Cos’è una <em>lambda</em> e come si legge</h2>
<pre><code class="language-cpp">// Forma generale (schema mentale):
[capture] (parametri) -&gt; tipo_ritorno {
    // corpo
}

// Esempi minimi:
auto somma   = [](int a, int b) { return a + b; };   // ritorno dedotto
int soglia = 9;
auto sopraS = [soglia](double m){ return m &gt;= soglia; }; // cattura by value (copia)
auto incS   = [&soglia](){ soglia++; };                  // cattura by reference (alias)
</code></pre>
      <ul>
        <li><b>Capture</b>: cosa “importa” dal contesto esterno. Usa catture mirate (<code>[x]</code>, <code>[&amp;x]</code>), evita <code>[=]</code>/<code>[&amp;]</code> indiscriminati.</li>
        <li><b>Parametri</b>: come una funzione normale (<code>(const Studente&amp; s)</code>...).</li>
        <li><b>Ritorno</b>: di solito dedotto; usa <code>-&gt; bool</code>/<code>-&gt; double</code> se il corpo ha rami multipli.</li>
        <li>Una lambda senza catture si può convertire a <em>puntatore a funzione</em>; con catture no.</li>
      </ul>
      <p class="ok"><b>Intuizione didattica</b>: pensa alla lambda come a una “funzione piccola” incollata vicino a dove ti serve.</p>
    </div>

    <!-- Ordinamenti -->
    <div class="box">
      <h2>C++ — Ordinare con <code>std::sort</code> / <code>stable_sort</code> e lambda</h2>
<pre><code class="language-cpp">#include &lt;algorithm&gt; // sort, stable_sort

// 1) Cognome crescente
std::sort(classe.begin(), classe.end(),
          [](const Studente&amp; a, const Studente&amp; b){
              return a.cognome &lt; b.cognome;
          });

// 2) Cognome, poi nome (tie-break deterministico)
std::sort(classe.begin(), classe.end(),
          [](const Studente&amp; a, const Studente&amp; b){
              if (a.cognome != b.cognome) return a.cognome &lt; b.cognome;
              return a.nome &lt; b.nome;
          });

// 3) Media decrescente
std::sort(classe.begin(), classe.end(),
          [](const Studente&amp; a, const Studente&amp; b){
              return a.media &gt; b.media;
          });

// 4) Ordinamento stabile per età (preserva l'ordine tra pari)
std::stable_sort(classe.begin(), classe.end(),
                 [](const Studente&amp; a, const Studente&amp; b){
                     return a.eta &lt; b.eta;
                 });
</code></pre>
      <p class="note"><b>Comparatori coerenti</b>: devono definire un <em>ordinamento debole stretto</em>. Un trucco: componi i confronti a cascata come nell’esempio “cognome poi nome”.</p>
    </div>

    <!-- Ricerca, conteggio, filtro -->
    <div class="box">
      <h2>C++ — Ricerca, conteggio e filtro</h2>
<pre><code class="language-cpp">#include &lt;algorithm&gt;

// find_if: primo con media &gt;= soglia
double k = 9.5;
auto it = std::find_if(classe.begin(), classe.end(),
                       [k](const Studente&amp; s){ return s.media &gt;= k; });
if (it != classe.end()) {
    // *it è lo Studente trovato
}

// count_if: quanti maggiorenni
int quanti = std::count_if(classe.begin(), classe.end(),
                           [](const Studente&amp; s){ return s.eta &gt;= 18; });

// erase-remove_if: filtra in-place chi ha media &lt; 6
classe.erase(std::remove_if(classe.begin(), classe.end(),
                            [](const Studente&amp; s){ return s.media &lt; 6.0; }),
             classe.end());
</code></pre>
      <p class="ok"><b>Erase–remove idiom</b> (step-by-step): <code>remove_if</code> compatt<a> gli elementi “da tenere” in testa e restituisce un iteratore alla nuova “fine logica”; <code>erase</code> elimina la coda fisicamente.</p>
    </div>

    <!-- Aggregazioni -->
    <div class="box">
      <h2>C++ — Aggregazioni (media, massimo) con lambda</h2>
<pre><code class="language-cpp">#include &lt;numeric&gt;   // accumulate
#include &lt;algorithm&gt; // max_element

double somma = std::accumulate(classe.begin(), classe.end(), 0.0,
                               [](double acc, const Studente&amp; s){
                                   return acc + s.media;
                               });
double mediaClasse = classe.empty() ? 0.0 : somma / classe.size();

auto itBest = std::max_element(classe.begin(), classe.end(),
                               [](const Studente&amp; a, const Studente&amp; b){
                                   return a.media &lt; b.media; // true se a "peggio" di b
                               });
</code></pre>
      <p class="tip">Le lambda incapsulano la “logica di confronto/somma” accanto all’algoritmo: leggibilità ⬆, errori ⬇.</p>
    </div>

    <!-- Pitfall -->
    <div class="inner-box">
      <h2>Pitfall comuni (e rimedi pratici)</h2>
      <ul>
        <li><b>Catture troppo ampie</b> (<code>[=]</code> / <code>[&amp;]</code>) → difficile capire cosa usa la lambda. <br/><br/><span class="ok">Catture mirate: <code>[k]</code>, <code>[&amp;k]</code>.</span></li>
        <li><b>Comparatori incoerenti</b> (es. usare <code>&lt;=</code>) → sort non deterministico. <br/><br/><span class="ok">Usa <code>&lt;</code> e tie-break chiari.</span></li>
        <li><b>Erase senza remove</b> (o viceversa) → risultato inatteso. <br/><br/><span class="ok">Usa sempre la coppia <code>erase(remove_if(...), end)</code>.</span></li>
        <li><b>Copie inutili</b> negli algoritmi STL. <br/><br/><span class="ok">Itera con <code>const auto&amp;</code>; usa <code>emplace_back</code> quando costruisci.</span></li>
      </ul>
    </div>

    <!-- Parte C -->
    <div class="box">
      <h2>C — Array di struct e <code>qsort</code> con funzione di confronto</h2>
<pre><code class="language-c">#include &lt;stdlib.h&gt;  // qsort
#include &lt;string.h&gt;  // strcmp

typedef struct {
    char nome[32], cognome[32];
    int eta;
    double media;
} Studente;

int cmp_cognome_nome(const void* pa, const void* pb) {
    const Studente* a = (const Studente*)pa;
    const Studente* b = (const Studente*)pb;
    int r = strcmp(a-&gt;cognome, b-&gt;cognome);
    if (r != 0) return r;                  // negativo: a&lt;b; positivo: a&gt;b
    return strcmp(a-&gt;nome, b-&gt;nome);
}

int cmp_media_desc(const void* pa, const void* pb) {
    const Studente* a = (const Studente*)pa;
    const Studente* b = (const Studente*)pb;
    if (a-&gt;media &lt; b-&gt;media) return  1;   // b prima di a
    if (a-&gt;media &gt; b-&gt;media) return -1;   // a prima di b
    return 0;
}

int main(void) {
    Studente v[] = {
        {"Ada","Lovelace",17,9.4},
        {"Alan","Turing",18,10.0},
        {"Edsger","Dijkstra",19,9.1}
    };
    size_t n = sizeof v / sizeof *v;
    qsort(v, n, sizeof *v, cmp_cognome_nome);
    // qsort(v, n, sizeof *v, cmp_media_desc);
    return 0;
}
</code></pre>
      <p class="note">In C non esistono le lambda: <code>qsort</code> richiede un <b>puntatore a funzione</b> che sappia confrontare due elementi generici (cast da <code>void*</code>).</p>
    </div>

    <!-- Esercizi -->
    <div class="inner-box">
      <h2>Esercizi (testi completi + soluzioni a comparsa)</h2>
      <ol>
        <li><b>E1 — Ordinamento multi-chiave (C++)</b><br/>
          <em>Input</em>: <code>std::vector&lt;Studente&gt;</code>.<br/>
          <em>Richiesta</em>: ordina per <u>cognome crescente</u>, poi <u>nome crescente</u>, poi <u>media decrescente</u> (tie-break deterministico).<br/>
          <div class="nav-buttons" style="justify-content:left"><button id="btn-e1" onclick="toggleBox('btn-e1','box-e1')">Mostra ▼</button></div>
          <div id="box-e1" style="display:none;margin-top:8px">
<pre><code class="language-cpp">std::sort(classe.begin(), classe.end(),
          [](const Studente&amp; a, const Studente&amp; b){
              if (a.cognome != b.cognome) return a.cognome &lt; b.cognome;
              if (a.nome    != b.nome   ) return a.nome    &lt; b.nome;
              return a.media &gt; b.media; // decrescente
          });
</code></pre>
          </div>
        </li>

        <li><b>E2 — Filtra promossi (C++)</b><br/>
          <em>Input</em>: <code>std::vector&lt;Studente&gt;</code>; soglia promozione <code>k</code> (double).<br/>
          <em>Richiesta</em>: crea un nuovo vector con chi ha <code>media ≥ k</code> e <code>eta ≥ 14</code>, senza modificare l’originale.<br/>
          <div class="nav-buttons" style="justify-content:left"><button id="btn-e2" onclick="toggleBox('btn-e2','box-e2')">Mostra ▼</button></div>
          <div id="box-e2" style="display:none;margin-top:8px">
<pre><code class="language-cpp">double k = 6.0;
std::vector&lt;Studente&gt; promossi;
promossi.reserve(classe.size());
std::copy_if(classe.begin(), classe.end(), std::back_inserter(promossi),
             [k](const Studente&amp; s){ return s.media &gt;= k &amp;&amp; s.eta &gt;= 14; });
</code></pre>
          </div>
        </li>

        <li><b>E3 — Primo insufficiente (C++)</b><br/>
          <em>Input</em>: vector e soglia <code>t</code>.<br/>
          <em>Richiesta</em>: usa <code>find_if</code> per ottenere il primo studente con <code>media &lt; t</code>; se non c’è, segnalarlo.<br/>
          <div class="nav-buttons" style="justify-content:left"><button id="btn-e3" onclick="toggleBox('btn-e3','box-e3')">Mostra ▼</button></div>
          <div id="box-e3" style="display:none;margin-top:8px">
<pre><code class="language-cpp">double t = 6.0;
auto it = std::find_if(classe.begin(), classe.end(),
                       [t](const Studente&amp; s){ return s.media &lt; t; });
if (it == classe.end()) {
    // nessuno sotto soglia
} else {
    // *it è il primo sotto soglia
}
</code></pre>
          </div>
        </li>

        <li><b>E4 — qsort per media decrescente (C)</b><br/>
          <em>Input</em>: array C di <code>Studente</code> e lunghezza.<br/>
          <em>Richiesta</em>: implementa il comparatore per media decrescente e chiama <code>qsort</code>.<br/>
          <div class="nav-buttons" style="justify-content:left"><button id="btn-e4" onclick="toggleBox('btn-e4','box-e4')">Mostra ▼</button></div>
          <div id="box-e4" style="display:none;margin-top:8px">
<pre><code class="language-c">int cmp_media_desc(const void* pa, const void* pb) {
    const Studente* a = (const Studente*)pa;
    const Studente* b = (const Studente*)pb;
    if (a-&gt;media &lt; b-&gt;media) return 1;   // b prima di a
    if (a-&gt;media &gt; b-&gt;media) return -1;  // a prima di b
    return 0;
}
// qsort(v, n, sizeof *v, cmp_media_desc);
</code></pre>
          </div>
        </li>
      </ol>
    </div>

    <div class="inner-box box">
      <h2>Takeaways</h2>
      <ul>
        <li><code>std::vector&lt;T&gt;</code> è la struttura base per collezioni di record in C++: dinamico, contiguo, ben supportato dagli algoritmi STL.</li>
        <li>Le <b>lambda</b> sono “funzioni inline” con catture: predicati e comparatori diventano chiari e locali.</li>
        <li><code>std::sort</code>/<code>stable_sort</code> + lambda per ordinare; <code>find_if</code>/<code>count_if</code>/<code>copy_if</code> per leggere; <code>erase_remove_if</code> per filtrare in-place.</li>
        <li>In C si usa <code>qsort</code> con un <b>puntatore a funzione</b> di confronto (niente lambda standard).</li>
      </ul>
    </div>

  </div>

  <div class="nav-buttons">
    <button onclick="prevSlide()">&#8592; Indietro</button>
    <button onclick="nextSlide()">Avanti &#8594;</button>
  </div>
</div>

<script>
function toggleMenu(){ document.getElementById('menu').classList.toggle('open'); }
</script>
</body>
</html>
