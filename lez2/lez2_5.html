<!DOCTYPE html>
<html lang="it">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>4BIA – Lez2.5 · Struct: layout in memoria, sizeof, padding & allineamento</title>
  <link rel="stylesheet" href="../style.css">
  <link rel="stylesheet" href="../default.css">
  <script src="../highlight.js"></script>
  <script>try{hljs.highlightAll();}catch(e){}</script>
  <script>
    function prevSlide(){ window.location.href = "lez2_4.html"; }
    function nextSlide(){ window.location.href = "lez2_6.html"; } // placeholder prossima
    function toggleMenu(){ document.getElementById('menu').classList.toggle('open'); }
    function toggleBox(btnId, boxId){
      const box = document.getElementById(boxId);
      const btn = document.getElementById(btnId);
      const open = box.style.display === 'block';
      box.style.display = open ? 'none' : 'block';
      if(btn) btn.textContent = open ? 'Mostra soluzione ▼' : 'Nascondi soluzione ▲';
    }
  </script>
  <style>
    .box { background:var(--panel,#fff); border-radius:12px; padding:12px; box-shadow:0 2px 6px rgba(0,0,0,.08); margin-bottom:14px }
    .note { background:#f7faff; border-left:4px solid #3b82f6; padding:.6rem .8rem; border-radius:8px }
    .warn { background:#fff7ed; border-left:4px solid #f59e0b; padding:.6rem .8rem; border-radius:8px }
    .ok   { background:#eefbf1; border-left:4px solid #22c55e; padding:.6rem .8rem; border-radius:8px }
    .tip  { font-style: italic; opacity:.9 }

    .spec { margin:.2rem 0 .5rem }
    .spec b { display:inline-block; width:10.5rem }

    /* hard-left per liste e blocchi codice */
    .inner-box, .inner-box p, .inner-box ul, .inner-box li, .inner-box h2, .inner-box h3 { text-align:left !important; }
    .inner-box ul { margin:.5rem 0 .75rem 1.25rem; padding-left:1.25rem; list-style-position: outside; }
    .inner-box ol { margin:.5rem 0 .75rem 1.4rem; padding-left:1.4rem; list-style-position: outside; }
    .inner-box li { margin:.3rem 0; padding-left:.1rem; }

    .inner-box pre,
    .inner-box pre code,
    .box pre,
    .box pre code,
    pre,
    pre code { text-align: left !important; }
    pre { white-space: pre; tab-size: 4; margin: 0 0 1rem 0; padding: .5rem .75rem; }
    pre code { display:block; }
  </style>
</head>
<body>
<!-- BEGIN MENU -->
<button class="menu-toggle" onclick="toggleMenu()">&#9776; Menu</button>
<div class="sidebar" id="menu">
  <h2>Lezione 2 — Struct (ripasso mirato)</h2>
  <ul>
    <li><a href="lez2_1.html">Lez2.1: Motivazione &amp; sintassi base</a></li>
    <li><a href="lez2_2.html">Lez2.2: Inizializzazioni in C/C++</a></li>
    <li><a href="lez2_3.html">Lez2.3: Passaggio a funzione</a></li>
    <li><a href="lez2_4.html">Lez2.4: Collezioni di struct &amp; lambda</a></li>
    <li><a href="lez2_5.html" class="active">Lez2.5: Layout, sizeof, padding &amp; align</a></li>
  </ul>
</div>
<!-- END MENU -->

<div class="slide">
  <h1>Lez2.5 — Layout in memoria, <code>sizeof</code>, padding &amp; allineamento</h1>

  <div class="nav-buttons" style="margin-bottom:10px">
    <button onclick="prevSlide()">&#8592; Indietro</button>
    <button onclick="nextSlide()">Avanti &#8594;</button>
  </div>

  <div class="content-box">

    <div class="inner-box box">
      <h2>Glossario minimo (per partire con sicurezza)</h2>
      <ul>
        <li><b>Allineamento</b>: alcuni tipi “preferiscono” indirizzi multipli (2, 4, 8 byte…). La piattaforma fissa la regola e il compilatore la rispetta.</li>
        <li><b>Padding</b>: byte cuscinetto inseriti dal compilatore prima o dopo i campi così ogni campo inizia allineato.</li>
        <li><b><code>sizeof(T)</code></b>: misura in byte l’intero oggetto, padding compreso.</li>
        <li><b><code>alignof(T)</code> / <code>_Alignof(T)</code></b>: multiplo minimo di byte richiesto dal tipo.</li>
        <li><b>Offset</b>: distanza in byte tra l’inizio della struct e un campo, ottenibile con <code>offsetof</code>.</li>
      </ul>
      <p class="ok"><b>Idea guida</b>: il layout dipende dall’accoppiata compilatore + ABI. Niente supposizioni: si osserva con <code>sizeof</code>, <code>alignof</code> e <code>offsetof</code>.</p>
    </div>

    <div class="inner-box">
      <h2>Perché contano layout, padding e allineamento</h2>
      <p>
        Una <strong>struct</strong> deve rispettare regole fisiche di allineamento della piattaforma. Per questo il compilatore
        può inserire <strong>padding</strong> tra i campi o alla fine dell’oggetto: è normale che <code>sizeof(T)</code> superi
        la somma dei singoli <code>sizeof</code>.
      </p>
      <ul>
        <li><strong>Allineamento</strong>: esempi comuni sono gli <code>int</code> multipli di 4 byte e i <code>double</code> multipli di 8 byte.</li>
        <li><strong>Padding interno</strong>: byte aggiunti fra due campi per allineare il campo successivo.</li>
        <li><strong>Padding finale</strong>: byte conclusivi che mantengono l’allineamento quando la struct è in un array.</li>
      </ul>
      <p class="warn"><strong>Portabilità:</strong> dimensioni e layout sono <em>implementation-defined</em>. Quindi si <b>misura</b>, non si indovina.</p>
    </div>

    <!-- C++ PRIMA -->
    <div class="box">
      <h2>C++ — Osservare <code>sizeof</code> e <code>alignof</code> (esempi)</h2>
      <p>Il modo più sicuro per capire il layout è stamparne le misure. Il frammento seguente raccoglie <code>sizeof</code>, <code>alignof</code> e <code>offsetof</code> per due struct con gli stessi campi ma ordine diverso.</p>
<pre><code class="language-cpp">#include &lt;cstddef&gt;   // std::size_t, offsetof
#include &lt;iostream&gt;

struct A {
    char  c;   // 1 byte
    int   i;   // 4 byte (tipico)
    double d;  // 8 byte (tipico)
};

struct B {
    char  c;
    double d;
    int   i;
};

int main() {
    std::cout &lt;&lt; "sizeof(char): "   &lt;&lt; sizeof(char)   &lt;&lt; "\n";
    std::cout &lt;&lt; "sizeof(int): "    &lt;&lt; sizeof(int)    &lt;&lt; "\n";
    std::cout &lt;&lt; "sizeof(double): " &lt;&lt; sizeof(double) &lt;&lt; "\n\n";

    std::cout &lt;&lt; "sizeof(A): " &lt;&lt; sizeof(A)
              &lt;&lt; ", alignof(A): " &lt;&lt; alignof(A) &lt;&lt; "\n";
    std::cout &lt;&lt; "  offsetof(A,c)=" &lt;&lt; offsetof(A,c)
              &lt;&lt; ", offsetof(A,i)=" &lt;&lt; offsetof(A,i)
              &lt;&lt; ", offsetof(A,d)=" &lt;&lt; offsetof(A,d) &lt;&lt; "\n";

    std::cout &lt;&lt; "sizeof(B): " &lt;&lt; sizeof(B)
              &lt;&lt; ", alignof(B): " &lt;&lt; alignof(B) &lt;&lt; "\n";
    std::cout &lt;&lt; "  offsetof(B,c)=" &lt;&lt; offsetof(B,c)
              &lt;&lt; ", offsetof(B,d)=" &lt;&lt; offsetof(B,d)
              &lt;&lt; ", offsetof(B,i)=" &lt;&lt; offsetof(B,i) &lt;&lt; "\n";
}
</code></pre>
      <p class="note">
        Su ABI comuni x86-64 <code>sizeof(A)</code> è più grande di <code>sizeof(B)</code>: l’<code>int</code> piazzato prima del <code>double</code>
        costringe a inserire padding extra. <strong>Messaggio pratico:</strong> ordinare i campi dal più grande al più piccolo riduce spesso lo spreco.
      </p>

      <h3>Schema mentale (disposizione a byte)</h3>
<pre><code class="language-text">A:  [c][pad pad pad][i i i i][d d d d d d d d]
B:  [c][pad pad pad pad pad pad pad][d x8][i x4]
</code></pre>
      <p class="tip">I “pad” sono byte non usati per i dati; esistono solo per rispettare l’allineamento.</p>
    </div>

    <div class="box">
      <h2>C++ — Effetto dell’ordine dei campi</h2>
      <p>Due struct identiche nei tipi ma con ordine diverso evidenziano l’impatto del padding. Basta ricompilare con i campi riordinati per ottenere una versione più compatta.</p>
<pre><code class="language-cpp">struct C1 {         // ordine "sfavorevole"
    char  c;        // 1
    int   i;        // 4
    char  d;        // 1
    double x;       // 8
};

struct C2 {         // ordine "favorevole"
    double x;       // 8
    int    i;       // 4
    char   c;       // 1
    char   d;       // 1
};

static_assert(sizeof(C2) &lt;= sizeof(C1), "C2 non dovrebbe essere più grande di C1");
</code></pre>
      <p class="ok">Riordinare i campi non cambia la logica del programma ma rende la struttura più compatta e gentile con la cache, soprattutto in un <code>std::vector&lt;C2&gt;</code> esteso.</p>
    </div>

    <div class="box">
      <h2>C++ — <code>alignof</code>, <code>alignas</code> e <code>offsetof</code></h2>
      <p>Quando serve un controllo più fine conviene interrogare direttamente le API standard: <code>alignof</code> rivela il requisito, <code>alignas</code> consente di chiederne uno nuovo e <code>offsetof</code> dice dove finiscono i campi.</p>
<pre><code class="language-cpp">#include &lt;cstddef&gt;
#include &lt;iostream&gt;
#include &lt;cstdint&gt;

struct Packet {
    std::uint16_t len;  // allineamento tipico: 2
    std::uint8_t  id;   // 1
    // padding qui per allineare i successivi 4 byte…
    std::uint32_t crc;  // 4
};

struct alignas(16) Aligned { // forza allineamento dell'intera struct
    double v[2];
};

int main() {
    std::cout &lt;&lt; "alignof(Packet): " &lt;&lt; alignof(Packet) &lt;&lt; "\n";
    std::cout &lt;&lt; "offsetof(Packet, len)=" &lt;&lt; offsetof(Packet, len) &lt;&lt; "\n";
    std::cout &lt;&lt; "offsetof(Packet, id)="  &lt;&lt; offsetof(Packet, id)  &lt;&lt; "\n";
    std::cout &lt;&lt; "offsetof(Packet, crc)=" &lt;&lt; offsetof(Packet, crc) &lt;&lt; "\n";

    std::cout &lt;&lt; "alignof(Aligned): " &lt;&lt; alignof(Aligned)
              &lt;&lt; ", sizeof(Aligned): " &lt;&lt; sizeof(Aligned) &lt;&lt; "\n";
}
</code></pre>
      <p class="warn"><strong>Usa <code>alignas</code> con criterio:</strong> chiedere un allineamento più alto può far crescere <code>sizeof</code> (serve più padding) e quindi consumare più memoria.</p>
    </div>

    <div class="box">
      <h2>C++ — Padding, confronto e serializzazione</h2>
      <ul>
        <li><strong>Padding non inizializzato</strong>: i byte di padding possono contenere valori non definiti; leggerli o confrontarli è non portabile.</li>
        <li><strong>Confronti corretti</strong>: metti a confronto i <em>campi</em> significativi, non i byte grezzi con <code>memcmp</code>.</li>
        <li><strong>Serializzazione</strong>: scrivi i campi in modo esplicito o usa librerie dedicate, non riversare l’intera struct così com’è.</li>
      </ul>
<pre><code class="language-cpp">struct Studente {
    std::string nome, cognome;
    int    eta;
    double media;
};

bool equal(const Studente&amp; a, const Studente&amp; b) {
    return a.nome==b.nome &amp;&amp; a.cognome==b.cognome
        &amp;&amp; a.eta==b.eta &amp;&amp; a.media==b.media;
}
</code></pre>
      <p class="note">Per strutture POD molto semplici si può lavorare in binario conoscendo bene la piattaforma, ma rimane una scelta fragile e non portabile.</p>
    </div>

    <!-- PARTE C -->
    <div class="box">
      <h2>C — <code>sizeof</code>, <code>_Alignof</code>, <code>offsetof</code></h2>
      <p>In C gli strumenti sono analoghi: cambiano solo i nomi delle funzioni standard, introdotte dal C11.</p>
<pre><code class="language-c">#include &lt;stddef.h&gt;  // offsetof
#include &lt;stdio.h&gt;   // printf
#include &lt;stdalign.h&gt;// _Alignof (C11)

typedef struct {
    char c;     // 1
    int  i;     // 4
    double d;   // 8
} A;

int main(void) {
    printf("sizeof(A) = %zu\n", sizeof(A));
    printf("_Alignof(A) = %zu\n", _Alignof(A));
    printf("offsetof(A,c) = %zu\n", offsetof(A,c));
    printf("offsetof(A,i) = %zu\n", offsetof(A,i));
    printf("offsetof(A,d) = %zu\n", offsetof(A,d));
    return 0;
}
</code></pre>
      <p class="note">Le stesse regole viste in C++ valgono in C: layout e dimensioni cambiano a seconda dell’implementazione, quindi prima si misura e poi si decide.</p>
    </div>

    <div class="box">
      <h2>C — Riordinare i campi per ridurre il padding</h2>
      <p>Stesso gioco anche qui: stessi tipi, ordine diverso, dimensioni diverse. È un esperimento rapido da proporre agli studenti.</p>
<pre><code class="language-c">typedef struct {     // ordine sfavorevole
    char  c;
    int   i;
    char  d;
    double x;
} C1;

typedef struct {     // ordine favorevole
    double x;
    int    i;
    char   c;
    char   d;
} C2;
</code></pre>
      <p class="ok">Stesso messaggio: metti prima i tipi “grandi”, poi i “piccoli” → spesso <code>sizeof</code> diminuisce.</p>
    </div>

    <div class="box">
      <h2>C — <code>#pragma pack</code>? Meglio evitarlo (salvo casi specifici)</h2>
      <p>
        Alcuni compilatori offrono <code>#pragma pack</code> per ridurre o azzerare il padding. È una scorciatoia <strong>non portabile</strong>
        e può peggiorare le prestazioni (accessi disallineati). Se proprio serve, delimitane l’uso allo stretto indispensabile.
      </p>
    </div>

    <!-- FAQ -->
    <div class="inner-box box">
      <h2>FAQ — Domande ricorrenti</h2>
      <ul>
        <li><b>Perché <code>sizeof(T)</code> include il padding?</b> Perché in un array ogni elemento deve iniziare allineato: il padding finale garantisce che l’elemento successivo parta nel punto giusto.</li>
        <li><b>Posso dipendere dal layout esatto?</b> In generale no: cambia con compilatore, opzioni e piattaforma. Meglio misurare oppure progettare senza vincoli sul layout.</li>
        <li><b>Perché <code>memcmp</code> su due struct può fallire anche se “uguali”?</b> Il padding può contenere byte non inizializzati e diversi tra i due oggetti.</li>
      </ul>
    </div>

    <!-- ESERCIZI -->
    <div class="inner-box">
      <h2>Esercizi (testi completi + soluzioni a comparsa)</h2>
      <ol>
        <li><strong>E1 — Misura e confronta (C++)</strong><br/>
          <div class="spec"><b>Richiesta:</b> definisci <code>S1</code> e <code>S2</code> con gli stessi campi ma ordine diverso (<code>double,int,char,char</code> vs <code>char,int,char,double</code>). Stampa <code>sizeof</code>, <code>alignof</code> e gli <code>offsetof</code> principali, poi spiega la differenza.</div>
          <div class="nav-buttons" style="justify-content:left"><button id="btn-e1" onclick="toggleBox('btn-e1','box-e1')">Mostra soluzione ▼</button></div>
          <div id="box-e1" style="display:none;margin-top:8px">
<pre><code class="language-cpp">#include &lt;cstddef&gt;
#include &lt;iostream&gt;

struct S1 { double x; int i; char a; char b; };
struct S2 { char a; int i; char b; double x; };

template &lt;typename T&gt; void info(const char* nome){
    std::cout &lt;&lt; nome &lt;&lt; ": sizeof=" &lt;&lt; sizeof(T)
              &lt;&lt; " alignof=" &lt;&lt; alignof(T) &lt;&lt; "\n";
    std::cout &lt;&lt; "  off(a)=" &lt;&lt; offsetof(T,a)
              &lt;&lt; " off(i)=" &lt;&lt; offsetof(T,i)
              &lt;&lt; " off(b)=" &lt;&lt; offsetof(T,b)
              &lt;&lt; " off(x)=" &lt;&lt; offsetof(T,x) &lt;&lt; "\n";
}

int main(){ info&lt;S1&gt;("S1"); info&lt;S2&gt;("S2"); }
</code></pre>
            <p class="note">Su molte piattaforme <code>sizeof(S1) &lt;= sizeof(S2)</code> grazie a meno padding intermedio.</p>
          </div>
        </li>

        <li><strong>E2 — Array di struct: impatto del layout</strong><br/>
          <div class="spec"><b>Richiesta:</b> crea un <code>std::vector&lt;S2&gt;</code> con 1e6 elementi e uno di <code>S1</code>. Confronta la memoria stimata (<code>sizeof(T) * N</code>) e commenta l’effetto sulla cache.</div>
          <div class="nav-buttons" style="justify-content:left"><button id="btn-e2" onclick="toggleBox('btn-e2','box-e2')">Mostra soluzione ▼</button></div>
          <div id="box-e2" style="display:none;margin-top:8px">
<pre><code class="language-text">Memoria ≈ sizeof(T) * N. Se S1 è più compatto, un vettore di 1e6 elementi
occuperà meno RAM e avrà migliore località (più elementi per linea di cache).
</code></pre>
          </div>
        </li>

        <li><strong>E3 — Evita <code>memcmp</code> sulle struct</strong><br/>
          <div class="spec"><b>Richiesta:</b> argomenta perché <code>memcmp(&amp;a,&amp;b,sizeof(a))</code> è fragile e scrivi un <code>operator==</code> che confronti i campi reali.</div>
          <div class="nav-buttons" style="justify-content:left"><button id="btn-e3" onclick="toggleBox('btn-e3','box-e3')">Mostra soluzione ▼</button></div>
          <div id="box-e3" style="display:none;margin-top:8px">
<pre><code class="language-text">Il padding può contenere byte indeterminati: due oggetti "uguali" per campi
possono avere padding diverso ⇒ memcmp fallisce. Confrontare i CAMPI.
</code></pre>
<pre><code class="language-cpp">struct P { int x; double y; char tag; };
bool operator==(const P&amp; a, const P&amp; b){
    return a.x==b.x &amp;&amp; a.y==b.y &amp;&amp; a.tag==b.tag;
}
</code></pre>
          </div>
        </li>

        <li><strong>E4 (C) — Calcola <code>sizeof</code> e commenta</strong><br/>
          <div class="spec"><b>Richiesta:</b> in C crea <code>R1</code> (<code>char,double,int</code>) e <code>R2</code> (<code>double,int,char</code>), poi stampa i due <code>sizeof</code> e descrivi perché cambiano.</div>
          <div class="nav-buttons" style="justify-content:left"><button id="btn-e4" onclick="toggleBox('btn-e4','box-e4')">Mostra soluzione ▼</button></div>
          <div id="box-e4" style="display:none;margin-top:8px">
<pre><code class="language-c">#include &lt;stdio.h&gt;
typedef struct { char a; double b; int c; } R1;
typedef struct { double b; int c; char a; } R2;
int main(void){
    printf("sizeof(R1)=%zu sizeof(R2)=%zu\n", sizeof(R1), sizeof(R2));
    return 0;
}
</code></pre>
            <p class="note">Su molte ABI <code>R2</code> è più compatto: meno padding interno.</p>
          </div>
        </li>
      </ol>
    </div>

    <div class="inner-box box">
      <h2>Takeaways</h2>
      <ul>
        <li><strong><code>sizeof(T)</code></strong> restituisce la dimensione reale della struct, padding compreso.</li>
        <li><strong>Ordina i campi</strong> dal più “pesante” al più “leggero” quando possibile per ridurre il padding.</li>
        <li><strong>Misura</strong> con <code>sizeof</code>, <code>alignof</code>/<code>_Alignof</code> e <code>offsetof</code>: l’intuizione non basta.</li>
        <li><strong>Confronta i campi</strong>, non i byte grezzi: lascia stare <code>memcmp</code> su struct complesse.</li>
        <li><strong><code>#pragma pack</code></strong> è una soluzione estrema, poco portabile e con impatto prestazionale: usarlo solo se strettamente necessario.</li>
      </ul>
    </div>

  </div>

  <div class="nav-buttons">
    <button onclick="prevSlide()">&#8592; Indietro</button>
    <button onclick="nextSlide()">Avanti &#8594;</button>
  </div>
</div>

<script>
function toggleMenu(){ document.getElementById('menu').classList.toggle('open'); }
</script>
</body>
</html>
