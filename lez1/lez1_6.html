<!DOCTYPE html>
<html lang="it">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>4BIA – L1.6 · Matrici dinamiche (C++/C): contiguità, prestazioni, RAII</title>
  <link rel="stylesheet" href="../style.css">
  <link rel="stylesheet" href="../default.css">
  <script src="../highlight.js"></script>
  <script>try{hljs.highlightAll();}catch(e){}</script>
  <script>
    function prevSlide(){ window.location.href = "lez1_5.html"; }
    function nextSlide(){ window.location.href = "lez1_7.html"; }
    function toggleMenu(){ document.getElementById('menu').classList.toggle('open'); }
    function toggleBox(btnId, boxId){
      const box = document.getElementById(boxId);
      const btn = document.getElementById(btnId);
      const open = box.style.display === 'block';
      box.style.display = open ? 'none' : 'block';
      btn.textContent = open ? 'Mostra ▼' : 'Nascondi ▲';
    }
  </script>
</head>
<body>
<!-- BEGIN MENU -->
<button class="menu-toggle" onclick="toggleMenu()">&#9776; Menu</button>
<div class="sidebar" id="menu">
  <h2>Lezione 1 — Matrici 2D (4BIA)</h2>
  <ul>
    <li><a href="lez1_1.html">L1.1 · Introduzione & obiettivi</a></li>
    <li><a href="lez1_2.html">L1.2 · Definizioni, indici, row-major</a></li>
    <li><a href="lez1_3.html">L1.3 · Dichiarazione & attraversamento</a></li>
    <li><a href="lez1_4.html">L1.4 · I/O & utility</a></li>
    <li><a href="lez1_5.html">L1.5 · Passare matrici a funzione</a></li>
    <li><a href="lez1_6.html">L1.6 · Matrici dinamiche (C++/C)</a></li>
  </ul>
</div>
<!-- END MENU -->

<div class="slide">
  <h1>L1.6 — Matrici <em>dinamiche</em>: modelli, I/O, prestazioni</h1>
  <div class="nav-buttons" style="margin-bottom:10px">
    <button onclick="prevSlide()">&#8592; Indietro</button>
    <button onclick="nextSlide()">Avanti &#8594;</button>
  </div>

  <div class="content-box">

    <div class="inner-box">
      <h2>Obiettivi</h2>
      <ul>
        <li>Gestire matrici con dimensioni note <strong>a runtime</strong>.</li>
        <li>Capire <strong>contiguità</strong> vs strutture “jagged” e impatto su cache/locality.</li>
        <li>Fare <strong>I/O dinamico</strong> robusto; usare firme corrette in C e C++.</li>
      </ul>
    </div>

    <!-- C++: approccio consigliato -->
    <div class="inner-box">
      <h2>C++ · Approccio consigliato: buffer contiguo 1D + vista 2D</h2>
      <p><strong>Idea:</strong> <code>std::vector&lt;T&gt; buf(R*C)</code> in row-major; indicizza con <code>buf[r*C+c]</code>. RAII, contiguo, veloce.</p>
<pre><code class="language-cpp">#include &lt;vector&gt;
#include &lt;cstddef&gt;
struct MatrixView {
  int* data; std::size_t R, C;
  int& operator()(std::size_t r, std::size_t c)       { return data[r*C + c]; }
  int  operator()(std::size_t r, std::size_t c) const { return data[r*C + c]; }
};

MatrixView viewOf(std::vector&lt;int&gt;&amp; buf, std::size_t R, std::size_t C){
  return MatrixView{ buf.data(), R, C };
}
</code></pre>
      <p class="note">Passaggio a funzione: preferisci <code>(buf, R, C)</code> o una <em>vista</em> (const/non-const).</p>
    </div>

    <!-- C++: vector<vector<T>> -->
    <div class="inner-box">
      <h2>C++ · <code>std::vector&lt;std::vector&lt;T&gt;&gt;</code> (jagged)</h2>
      <ul>
        <li>Pro: semplice; righe a lunghezze diverse.</li>
        <li>Contro: <strong>non contiguo</strong>; locality peggiore; doppia indirezione.</li>
      </ul>
<pre><code class="language-cpp">std::size_t R=4, C=6;
std::vector&lt;std::vector&lt;int&gt;&gt; m(R, std::vector&lt;int&gt;(C,0));
m[1][2] = 42; // ok, ma memoria frammentata
</code></pre>
    </div>

    <!-- C++: new/delete e unique_ptr -->
    <div class="inner-box">
      <h2>C++ · Alternative: <code>new[]</code> (sconsigliata) e <code>unique_ptr&lt;T[]&gt;</code></h2>
      <div class="twocol">
<pre><code class="language-cpp">// Contiguo con new[] (evita: preferisci vector)
std::size_t R=4, C=6;
int* data = new int[R*C]{}; // zero-init
auto at = [=](std::size_t r, std::size_t c) -&gt; int&amp; { return data[r*C+c]; };
// ... usa data ...
delete[] data;
</code></pre>
<pre><code class="language-cpp">// RAII senza vector: unique_ptr&lt;T[]&gt;
#include &lt;memory&gt;
std::unique_ptr&lt;int[]&gt; data(new int[R*C]());
auto at = [&](std::size_t r, std::size_t c) -&gt; int&amp; { return data[r*C+c]; }
// delete[] implicito via RAII
</code></pre>
      </div>
    </div>

    <!-- C: opzioni corrette -->
    <div class="inner-box">
      <h2>C · Opzioni corrette (contigue)</h2>
      <div class="twocol">
<pre><code class="language-c">// Pointer-to-array: righe contigue, C a runtime (C99)
int R=4, C=6;
int (*m)[C] = malloc((size_t)R * sizeof *m); // *m è "array di C int"
if(!m){/* handle error */}
m[1][2] = 42;
// ...
free(m);
</code></pre>
<pre><code class="language-c">// Buffer 1D piatto (row-major)
int R=4, C=6;
int *buf = malloc((size_t)R * (size_t)C * sizeof *buf);
if(!buf){/* handle error */}
#define AT(r,c) buf[(size_t)(r)*C + (size_t)(c)]
AT(1,2) = 42;
// ...
free(buf);
</code></pre>
      </div>
      <p class="note">Entrambe contigue. (1) consente sintassi <code>m[r][c]</code>; (2) è universale e si allinea a C++.</p>
    </div>

    <!-- C: VLA & anti-pattern -->
    <div class="inner-box">
      <h2>C · VLA e l’anti-pattern <code>int**</code></h2>
      <ul>
        <li><strong>VLA (C99):</strong> <code>int a[R][C]</code> con R,C a runtime (allocato sullo stack ⇒ occhio alla taglia).</li>
        <li><strong>Da evitare:</strong> <code>int**</code> con N allocazioni (una per riga): non contiguo, più fragile, incompatibile con firme <code>int a[][C]</code>.</li>
      </ul>
<pre><code class="language-c">// Anti-pattern (usare solo per righe di lunghezze diverse)
int **bad = malloc(R * sizeof *bad);
for(int r=0;r&lt;R;++r) bad[r] = malloc(C * sizeof *bad[r]);
// ...
for(int r=0;r&lt;R;++r) free(bad[r]); free(bad);
</code></pre>
    </div>

    <!-- I/O dinamico -->
    <div class="inner-box">
      <h2>I/O dinamico (C++ e C)</h2>
      <div class="twocol">
<pre><code class="language-cpp">// C++ — buffer contiguo
#include &lt;iostream&gt; #include &lt;iomanip&gt; #include &lt;vector&gt;
void leggi(std::vector&lt;int&gt;&amp; buf, std::size_t R, std::size_t C){
  buf.assign(R*C, 0);
  for(std::size_t r=0;r&lt;R;++r)
    for(std::size_t c=0;c&lt;C;++c)
      std::cin &gt;&gt; buf[r*C + c];
}
void stampa(const std::vector&lt;int&gt;&amp; buf, std::size_t R, std::size_t C, int w=4){
  std::cout &lt;&lt; "    "; for(std::size_t c=0;c&lt;C;++c) std::cout &lt;&lt; std::setw(w) &lt;&lt; c; std::cout &lt;&lt; "\n";
  for(std::size_t r=0;r&lt;R;++r){
    std::cout &lt;&lt; std::setw(3) &lt;&lt; r &lt;&lt; ":";
    for(std::size_t c=0;c&lt;C;++c) std::cout &lt;&lt; std::setw(w) &lt;&lt; buf[r*C + c];
    std::cout &lt;&lt; "\n";
  }
}
</code></pre>
<pre><code class="language-c">// C — pointer-to-array (VLA)
#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt;
void leggi(int R, int C, int m[R][C]){
  for(int r=0;r&lt;R;++r) for(int c=0;c&lt;C;++c) scanf("%d",&m[r][c]);
}
void stampa(int R, int C, const int m[R][C], int w){
  printf("    "); for(int c=0;c&lt;C;++c) printf("%*d",w,c); printf("\n");
  for(int r=0;r&lt;R;++r){ printf("%3d:",r);
    for(int c=0;c&lt;C;++c) printf("%*d",w,m[r][c]); printf("\n");
  }
}
</code></pre>
      </div>
    </div>

    <!-- Passare dinamiche a funzione -->
    <div class="inner-box">
      <h2>Passare matrici dinamiche a funzione</h2>
      <div class="twocol">
<pre><code class="language-cpp">// C++: buffer contiguo
void riempi(std::vector&lt;int&gt;&amp; buf, std::size_t R, std::size_t C, int v){
  for(std::size_t r=0;r&lt;R;++r)
    for(std::size_t c=0;c&lt;C;++c)
      buf[r*C + c] = v;
}
</code></pre>
<pre><code class="language-c">// C: VLA (ordine parametri importante)
void riempi(int R, int C, int m[R][C], int v){
  for(int r=0;r&lt;R;++r)
    for(int c=0;c&lt;C;++c)
      m[r][c] = v;
}
</code></pre>
      </div>
    </div>

    <!-- MINI TASK 1 -->
    <div class="inner-box">
      <h2>Mini-task 1 · Conversione jagged → contiguo</h2>
      <p>Data <code>std::vector&lt;std::vector&lt;int&gt;&gt; J</code> con righe tutte lunghe <code>C</code>, crea un buffer contiguo <code>V</code> (<code>R*C</code>) in row-major.</p>
      <div class="nav-buttons" style="justify-content:left">
        <button id="btn-t1" onclick="toggleBox('btn-t1','box-t1')">Mostra soluzione ▼</button>
      </div>
      <div id="box-t1" style="display:none;margin-top:8px">
<pre><code class="language-cpp">std::size_t R = J.size(), C = J.empty()?0:J[0].size();
std::vector&lt;int&gt; V; V.reserve(R*C);
for(std::size_t r=0;r&lt;R;++r){
  // assert(J[r].size()==C);
  V.insert(V.end(), J[r].begin(), J[r].end());
}
</code></pre>
      </div>
    </div>

    <!-- MINI TASK 2 -->
    <div class="inner-box">
      <h2>Mini-task 2 · Diagonale principale su buffer contiguo</h2>
      <p>Imposta la diagonale a 1 e il resto a 0 su <code>std::vector&lt;int&gt;&amp; buf</code> (<code>R×C</code>).</p>
      <div class="nav-buttons" style="justify-content:left">
        <button id="btn-t2" onclick="toggleBox('btn-t2','box-t2')">Mostra soluzione ▼</button>
      </div>
      <div id="box-t2" style="display:none;margin-top:8px">
<pre><code class="language-cpp">void setIdentity(std::vector&lt;int&gt;&amp; buf, std::size_t R, std::size_t C){
  std::fill(buf.begin(), buf.end(), 0);
  std::size_t d = (R&lt;C?R:C);
  for(std::size_t i=0;i&lt;d;++i) buf[i*C + i] = 1;
}
</code></pre>
      </div>
    </div>

    <!-- MINI TASK 3 -->
    <div class="inner-box">
      <h2>Mini-task 3 · C (heap contiguo) con sintassi <code>m[r][c]</code></h2>
      <p>Alloca <code>m</code> con <code>int (*m)[C]</code>, usalo e libera la memoria.</p>
      <div class="nav-buttons" style="justify-content:left">
        <button id="btn-t3" onclick="toggleBox('btn-t3','box-t3')">Mostra soluzione ▼</button>
      </div>
      <div id="box-t3" style="display:none;margin-top:8px">
<pre><code class="language-c">int R=5, C=7;
int (*m)[C] = malloc((size_t)R * sizeof *m);
if(!m){/* error */}
for(int r=0;r&lt;R;++r) for(int c=0;c&lt;C;++c) m[r][c]=r*C+c;
/* usa m[r][c] normalmente */
free(m);
</code></pre>
      </div>
    </div>

    <div class="inner-box">
      <h2>Takeaways</h2>
      <ul>
        <li><strong>Contiguità</strong> batte jagged per calcolo denso e cache.</li>
        <li><strong>C++:</strong> preferisci <code>std::vector&lt;T&gt;</code> + vista 2D; evita <code>new[]</code> manuale.</li>
        <li><strong>C:</strong> usa <code>int (*m)[C]</code> o buffer 1D; evita <code>int**</code> salvo reali esigenze jagged.</li>
        <li>Firme a funzione coerenti: (buf,R,C) in C++; in C usa VLA/pointer-to-array con <code>R,C</code> prima di <code>m[R][C]</code>.</li>
      </ul>
    </div>

  </div>

  <div class="nav-buttons">
    <button onclick="prevSlide()">&#8592; Indietro</button>
    <button onclick="nextSlide()">Avanti &#8594;</button>
  </div>
</div>

<script>
function toggleMenu(){ document.getElementById('menu').classList.toggle('open'); }
</script>
</body>
</html>
