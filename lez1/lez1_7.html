<!DOCTYPE html>
<html lang="it">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>4BIA – L1.7 · Operazioni base su matrici (somme, diagonali, simmetria)</title>
  <link rel="stylesheet" href="../style.css">
  <link rel="stylesheet" href="../default.css">
  <script src="../highlight.js"></script>
  <script>try{hljs.highlightAll();}catch(e){}</script>
  <script>
    function prevSlide(){ window.location.href = "lez1_6.html"; }
    function nextSlide(){ window.location.href = "lez1_8.html"; }
    function toggleMenu(){ document.getElementById('menu').classList.toggle('open'); }
    function toggleBox(btnId, boxId){
      const box = document.getElementById(boxId);
      const btn = document.getElementById(btnId);
      const open = box.style.display === 'block';
      box.style.display = open ? 'none' : 'block';
      btn.textContent = open ? 'Mostra ▼' : 'Nascondi ▲';
    }
  </script>
</head>
<body>
<!-- BEGIN MENU -->
<button class="menu-toggle" onclick="toggleMenu()">&#9776; Menu</button>
<div class="sidebar" id="menu">
  <h2>Lezione 1 — Matrici 2D (4BIA)</h2>
  <ul>
    <li><a href="lez1_1.html">L1.1 · Introduzione & obiettivi</a></li>
    <li><a href="lez1_2.html">L1.2 · Definizioni, indici, row-major</a></li>
    <li><a href="lez1_3.html">L1.3 · Dichiarazione & attraversamento</a></li>
    <li><a href="lez1_4.html">L1.4 · I/O & utility</a></li>
    <li><a href="lez1_5.html">L1.5 · Passare matrici a funzione</a></li>
    <li><a href="lez1_6.html">L1.6 · Matrici dinamiche</a></li>
    <li><a href="lez1_7.html">L1.7 · Operazioni base</a></li>
  </ul>
</div>
<!-- END MENU -->

<div class="slide">
  <h1>L1.7 — Operazioni base: somme, diagonali, traccia, simmetria, triangolarità</h1>
  <div class="nav-buttons" style="margin-bottom:10px">
    <button onclick="prevSlide()">&#8592; Indietro</button>
    <button onclick="nextSlide()">Avanti &#8594;</button>
  </div>

  <div class="content-box">

    <div class="inner-box">
      <h2>Obiettivi</h2>
      <ul>
        <li>Calcolare <strong>somme per riga/colonna</strong> in O(R·C) con corretta inizializzazione.</li>
        <li>Lavorare con <strong>diagonali</strong> e <strong>traccia</strong> (solo per matrici quadrate).</li>
        <li>Verificare <strong>simmetria</strong> e <strong>triangolarità</strong> percorrendo solo mezza matrice.</li>
        <li>Capire i casi limite e gli errori tipici (indici, inizializzazioni).</li>
      </ul>
    </div>

    <!-- SOMME PER RIGA / COLONNA -->
    <div class="inner-box">
      <h2>Somme per riga e per colonna</h2>
      <p><em>Idea:</em> inizializza due vettori <code>sr[R]</code>, <code>sc[C]</code> a 0; in un’unica scansione aggiorna entrambi.</p>
      <div class="twocol">
<pre><code class="language-cpp">// C++ (template, statico)
template&lt;std::size_t R, std::size_t C&gt;
void sommeRigaCol(const int (&amp;m)[R][C], int (&amp;sr)[R], int (&amp;sc)[C]){
  for (std::size_t r=0; r&lt;R; ++r) sr[r]=0;
  for (std::size_t c=0; c&lt;C; ++c) sc[c]=0;
  for (std::size_t r=0; r&lt;R; ++r)
    for (std::size_t c=0; c&lt;C; ++c){
      sr[r] += m[r][c];
      sc[c] += m[r][c];
    }
}
</code></pre>
<pre><code class="language-c">// C (VLA)
void somme_riga_col(int R,int C,const int m[R][C], int sr[R], int sc[C]){
  for(int r=0;r&lt;R;++r) sr[r]=0;
  for(int c=0;c&lt;C;++c) sc[c]=0;
  for(int r=0;r&lt;R;++r)
    for(int c=0;c&lt;C;++c){
      sr[r]+=m[r][c];
      sc[c]+=m[r][c];
    }
}
</code></pre>
      </div>
      <p class="note">⚠️ Dimenticare l’azzeramento produce risultati errati (accumulo “spazzatura”). Complessità: O(R·C), contante spazio extra.</p>
    </div>

    <!-- DIAGONALI & TRACCIA -->
    <div class="inner-box">
      <h2>Diagonali e traccia (matrici quadrate)</h2>
      <ul>
        <li><strong>Traccia</strong> <code>tr(M) = Σ_i M[i][i]</code>.</li>
        <li><strong>Secondaria</strong>: indice <code>(i, N−1−i)</code>.</li>
        <li>Check quadratezza: richiedi <code>R==C</code> a compile time (template) o a runtime (C/VLA).</li>
      </ul>
      <div class="twocol">
<pre><code class="language-cpp">// C++ (template su N)
template&lt;std::size_t N&gt;
int traccia(const int (&amp;m)[N][N]){
  int t=0; for(std::size_t i=0;i&lt;N;++i) t+=m[i][i]; return t;
}
template&lt;std::size_t N&gt;
int sommaDiagSecondaria(const int (&amp;m)[N][N]){
  int s=0; for(std::size_t i=0;i&lt;N;++i) s+=m[i][N-1-i]; return s;
}
</code></pre>
<pre><code class="language-c">// C (VLA)
int traccia(int N, const int m[N][N]){
  int t=0; for(int i=0;i&lt;N;++i) t+=m[i][i]; return t;
}
int somma_diag_secondaria(int N, const int m[N][N]){
  int s=0; for(int i=0;i&lt;N;++i) s+=m[i][N-1-i]; return s;
}
</code></pre>
      </div>
    </div>

    <!-- SIMMETRIA -->
    <div class="inner-box">
      <h2>Simmetria: percorrere solo metà matrice</h2>
      <p><em>Definizione:</em> <code>M</code> è simmetrica ⇔ <code>M[i][j] == M[j][i]</code> per tutti <code>i,j</code>.</p>
      <div class="twocol">
<pre><code class="language-cpp">// C++ (template, O(N^2/2))
template&lt;std::size_t N&gt;
bool simmetrica(const int (&amp;m)[N][N]){
  for(std::size_t i=0;i&lt;N;++i)
    for(std::size_t j=i+1;j&lt;N;++j)
      if(m[i][j]!=m[j][i]) return false;
  return true;
}
</code></pre>
<pre><code class="language-c">// C (VLA)
bool simmetrica(int N, const int m[N][N]){
  for(int i=0;i&lt;N;++i)
    for(int j=i+1;j&lt;N;++j)
      if(m[i][j]!=m[j][i]) return false;
  return true;
}
</code></pre>
      </div>
      <p class="note">Scansionare solo il triangolo superiore evita confronti doppi e l’asse principale.</p>
    </div>

    <!-- TRIANGOLARITÀ -->
    <div class="inner-box">
      <h2>Triangolarità (superiore/inferiore)</h2>
      <ul>
        <li><strong>Triangolare superiore</strong>: tutti gli elementi con <code>i &gt; j</code> sono 0.</li>
        <li><strong>Triangolare inferiore</strong>: tutti gli elementi con <code>i &lt; j</code> sono 0.</li>
      </ul>
      <div class="twocol">
<pre><code class="language-cpp">// C++ (template)
template&lt;std::size_t N&gt;
bool triangolareSuperiore(const int (&amp;m)[N][N]){
  for(std::size_t i=1;i&lt;N;++i)
    for(std::size_t j=0;j&lt;i;++j)
      if(m[i][j]!=0) return false;
  return true;
}
</code></pre>
<pre><code class="language-c">// C (VLA)
bool triangolare_inferiore(int N, const int m[N][N]){
  for(int i=0;i&lt;N-1;++i)
    for(int j=i+1;j&lt;N;++j)
      if(m[i][j]!=0) return false;
  return true;
}
</code></pre>
      </div>
      <p class="note">La verifica visita solo metà matrice (esclusa la diagonale). Complessità O(N²/2).</p>
    </div>

    <!-- MINI-TASK 1 -->
    <div class="inner-box">
      <h2>Mini-task 1 · Trasposta in-place (quadrata)</h2>
      <p>Scambia <code>M[i][j]</code> con <code>M[j][i]</code> per <code>j&gt;i</code>. Evita doppi swap e lascia invariata la diagonale.</p>
      <div class="nav-buttons" style="justify-content:left">
        <button id="btn-t1" onclick="toggleBox('btn-t1','box-t1')">Mostra soluzione ▼</button>
      </div>
      <div id="box-t1" style="display:none;margin-top:8px">
        <div class="twocol">
<pre><code class="language-cpp">// C++ (template)
template&lt;std::size_t N&gt;
void traspostaInPlace(int (&amp;m)[N][N]){
  for(std::size_t i=0;i&lt;N;++i)
    for(std::size_t j=i+1;j&lt;N;++j)
      std::swap(m[i][j], m[j][i]);
}
</code></pre>
<pre><code class="language-c">// C (VLA)
void trasposta_in_place(int N, int m[N][N]){
  for(int i=0;i&lt;N;++i)
    for(int j=i+1;j&lt;N;++j){
      int t=m[i][j]; m[i][j]=m[j][i]; m[j][i]=t;
    }
}
</code></pre>
        </div>
      </div>
    </div>

    <!-- MINI-TASK 2 -->
    <div class="inner-box">
      <h2>Mini-task 2 · Maschera diagonale</h2>
      <p>Dato <code>M</code> quadrata, azzera tutto tranne la diagonale principale (imposta la diagonale a 1 se vuoi un’identità).</p>
      <div class="nav-buttons" style="justify-content:left">
        <button id="btn-t2" onclick="toggleBox('btn-t2','box-t2')">Mostra soluzione ▼</button>
      </div>
      <div id="box-t2" style="display:none;margin-top:8px">
        <div class="twocol">
<pre><code class="language-cpp">// C++ (template)
template&lt;std::size_t N&gt;
void keepMainDiagonal(int (&amp;m)[N][N], int diag=1){
  for(std::size_t i=0;i&lt;N;++i)
    for(std::size_t j=0;j&lt;N;++j)
      m[i][j] = (i==j ? diag : 0);
}
</code></pre>
<pre><code class="language-c">// C (VLA)
void keep_main_diagonal(int N, int m[N][N], int diag){
  for(int i=0;i&lt;N;++i)
    for(int j=0;j&lt;N;++j)
      m[i][j] = (i==j ? diag : 0);
}
</code></pre>
        </div>
      </div>
    </div>

    <!-- MINI-TASK 3 -->
    <div class="inner-box">
      <h2>Mini-task 3 · Massimo di ogni riga (dinamico contiguo)</h2>
      <p>Usa buffer contiguo (<code>std::vector&lt;int&gt;</code>) per restituire i massimi per riga in O(R·C).</p>
      <div class="nav-buttons" style="justify-content:left">
        <button id="btn-t3" onclick="toggleBox('btn-t3','box-t3')">Mostra soluzione ▼</button>
      </div>
      <div id="box-t3" style="display:none;margin-top:8px">
<pre><code class="language-cpp">#include &lt;vector&gt;
std::vector&lt;int&gt; maxPerRiga(const std::vector&lt;int&gt;&amp; buf, std::size_t R, std::size_t C){
  std::vector&lt;int&gt; mx(R);
  for(std::size_t r=0;r&lt;R;++r){
    int m = buf[r*C + 0];
    for(std::size_t c=1;c&lt;C;++c) if(buf[r*C + c] &gt; m) m = buf[r*C + c];
    mx[r] = m;
  }
  return mx;
}
</code></pre>
        <p class="note">Stessa idea per i <em>minimi</em> e per i <em>massimi per colonna</em> (attenzione alla locality).</p>
      </div>
    </div>

    <div class="inner-box">
      <h2>Takeaways</h2>
      <ul>
        <li>Molte proprietà (simmetria, triangolarità) si verificano su <strong>mezza matrice</strong>.</li>
        <li>Inizializzazioni corrette (es. vettori di somma) evitano bug silenziosi.</li>
        <li>Le stesse tecniche valgono per rappresentazioni <strong>dinamiche contigue</strong> (buffer 1D), cambiando l’indicizzazione.</li>
      </ul>
    </div>

  </div>

  <div class="nav-buttons">
    <button onclick="prevSlide()">&#8592; Indietro</button>
    <button onclick="nextSlide()">Avanti &#8594;</button>
  </div>
</div>

<script>
function toggleMenu(){ document.getElementById('menu').classList.toggle('open'); }
</script>
</body>
</html>
