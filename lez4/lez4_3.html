<!DOCTYPE html>
<html lang="it">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>4BIA – Lez4_3 · Costruttori, distruttore, lista di inizializzazione</title>

  <link rel="stylesheet" href="../style.css">
  <link rel="stylesheet" href="../default.css">
  <script src="../highlight.js"></script>
  <script>try{hljs.highlightAll();}catch(e){}</script>

  <script>
    function prevSlide(){ window.location.href = "lez4_2.html"; }
    function nextSlide(){ window.location.href = "lez4_4.html"; }
    function toggleMenu(){ document.getElementById('menu').classList.toggle('open'); }
    function toggleBox(btnId, boxId){
      const box=document.getElementById(boxId), btn=document.getElementById(btnId);
      const open = box.style.display==='block';
      box.style.display = open ? 'none' : 'block';
      if(btn) btn.textContent = open ? 'Mostra ▼' : 'Nascondi ▲';
    }
  </script>

  <style>
    /* Allineamento forte a sinistra e stile coerente */
    .inner-box, .inner-box p, .inner-box ul, .inner-box ol, .inner-box li,
    .inner-box pre, .inner-box code, .inner-box h2, .inner-box h3 { text-align:left !important; }
    .inner-box ul, .inner-box ol { margin:.5rem 0 .75rem 1rem; padding-left:1.25rem; list-style-position:outside }
    .inner-box li { margin:.25rem 0 }
    pre, pre code { white-space:pre; tab-size:4; margin:0 0 1rem 0; padding:.5rem .75rem; }
    code { white-space:pre-wrap; }

    .box  { background:var(--panel,#fff); border-radius:12px; padding:12px; box-shadow:0 2px 6px rgba(0,0,0,.08); margin-bottom:14px }
    .note { background:#f7faff; border-left:4px solid #3b82f6; padding:.6rem .8rem; border-radius:8px; margin:.35rem 0 }
    .ok   { background:#eefbf1; border-left:4px solid #22c55e; padding:.6rem .8rem; border-radius:8px; margin:.35rem 0; display:inline-block }
    .warn { background:#fff7ed; border-left:4px solid #f59e0b; padding:.6rem .8rem; border-radius:8px; margin:.35rem 0 }
    .kbd  { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace; background:#f1f5f9; border:1px solid #e2e8f0; border-radius:6px; padding:0 .35rem }

    table { width:100%; border-collapse:collapse }
    th, td { border-bottom:1px solid #e5e7eb; padding:.45rem .5rem; text-align:left; vertical-align:top }
    th { background:#f8fafc }
  </style>
</head>
<body>

<!-- BEGIN MENU -->
<button class="menu-toggle" onclick="toggleMenu()">&#9776; Menu</button>
<div class="sidebar" id="menu">
  <h2>Lezione 4 — OOP in C++ (introduzione)</h2>
  <ul>
    <li><a href="lez4_1.html">Lez4_1: Perché OOP? Concetti di base</a></li>
    <li><a href="lez4_2.html">Lez4_2: Definire una classe (sintassi minima)</a></li>
    <li><a class="active" href="lez4_3.html">Lez4_3: Costruttori, distruttore, lista d’iniz.</a></li>
    <li><a href="lez4_4.html">Lez4_4: Incapsulamento, metodi const, overload</a></li>
    <li><a href="lez4_5.html">Lez4_5: to_string(), stampa, pre/postcondiz.</a></li>
    <li><a href="lez4_6.html">Lez4_6: Header/Sorgenti, include-guard, build</a></li>
  </ul>
</div>
<!-- END MENU -->

<div class="slide">
  <h1>Costruttori, distruttore e lista di inizializzazione</h1>

  <div class="nav-buttons" style="margin-bottom:10px">
    <button onclick="prevSlide()">&#8592; Indietro</button>
    <button onclick="nextSlide()">Avanti &#8594;</button>
  </div>

  <div class="content-box">

    <div class="inner-box box">
      <h2>Obiettivi</h2>
      <ul>
        <li>Capire a cosa servono i <strong>costruttori</strong> e la <strong>lista di inizializzazione</strong>.</li>
        <li>Conoscere il <strong>distruttore</strong> e quando è necessario (RAII, risorse).</li>
        <li>Usare inizializzatori di membro di default e la semantica <code>= default</code>/<code>= delete</code> (accenno).</li>
        <li>Scrivere classi che partono sempre in uno <strong>stato valido</strong> (invarianti rispettati).</li>
      </ul>
      <p class="ok"><b>Idea chiave:</b> i costruttori <em>inizializzano</em> i membri; la lista di inizializzazione porta i campi direttamente al primo valore corretto.</p>
    </div>

    <div class="inner-box box">
      <h2>Tipi di costruttori (panoramica pratica)</h2>
      <table>
        <thead><tr><th>Tipo</th><th>Uso</th><th>Esempio</th></tr></thead>
        <tbody>
          <tr>
            <td><b>Default</b></td>
            <td>Creare l’oggetto senza argomenti (stato “di base” sensato)</td>
            <td><code>Punto()</code></td>
          </tr>
          <tr>
            <td><b>Parametrico</b></td>
            <td>Impostare lo stato iniziale con parametri</td>
            <td><code>Punto(double x, double y)</code></td>
          </tr>
          <tr>
            <td><b>Di copia</b> (accenno)</td>
            <td>Costruire da un oggetto esistente</td>
            <td><code>Punto(const Punto&amp;)</code></td>
          </tr>
          <tr>
            <td><b>Di move</b> (accenno)</td>
            <td>Trasferire risorse da un oggetto “temporaneo”</td>
            <td><code>Punto(Punto&amp;&amp;)</code></td>
          </tr>
        </tbody>
      </table>
      <p class="note">Per ora useremo <b>default</b> e <b>parametrico</b>. Copia/move arriveranno più avanti (regola dello 0/5).</p>
    </div>

    <div class="inner-box box">
      <h2>Lista di inizializzazione: perché è importante</h2>
      <ul>
        <li>È la parte <code>: x_{...}, y_{...}</code> che segue la firma del costruttore.</li>
        <li>Inizializza <em>direttamente</em> i membri al loro primo valore (più efficiente e spesso necessario).</li>
        <li><b>Obbligatoria</b> per membri <code>const</code>, <code>&amp;</code> (reference) e oggetti-membro senza default sensato.</li>
        <li>L’<b>ordine reale</b> di inizializzazione è quello di <em>dichiarazione</em> dei membri, non l’ordine nella lista.</li>
      </ul>
<pre><code class="language-cpp">class Punto {
private:
    double x_, y_;
public:
    Punto() : x_{0.0}, y_{0.0} {}               // default
    Punto(double x, double y) : x_{x}, y_{y} {}  // parametrico
};</code></pre>
      <p class="warn"><b>Attenzione:</b> assegnare nel corpo del costruttore (<code>x_ = ...</code>) prima costruisce i membri con default, poi li riassegna. Con <code>const</code>/<code>&amp;</code> fallisce la compilazione.</p>
    </div>

    <div class="inner-box box">
      <h2>Esempio guidato: invariante con costruttori</h2>
<pre><code class="language-cpp">class Conto {
private:
    double saldo_{0.0};             // inizializzatore di membro di default
public:
    Conto() = default;              // default: saldo 0
    Conto(double s)                 // parametrico: valida e inizializza
    : saldo_{ (s &gt;= 0) ? s : 0.0 } {}  // garantisce saldo ≥ 0

    bool versa(double v){ if(v &lt; 0) return false; saldo_ += v; return true; }
    bool preleva(double v){ if(v &lt; 0 || v &gt; saldo_) return false; saldo_ -= v; return true; }
    double saldo() const { return saldo_; }
};</code></pre>
      <p class="ok">L’invariante “<code>saldo ≥ 0</code>” viene garantita <em>subito</em> dal costruttore: nessun oggetto può nascere in stato illegale.</p>
    </div>

    <div class="inner-box box">
      <h2>Costruttori con membri <code>const</code> e <code>reference</code></h2>
      <ul>
        <li>I membri <b><code>const</code></b> e <b><code>&amp;</code></b> <em>devono</em> essere inizializzati nella lista; non possono essere assegnati nel corpo.</li>
        <li>Ordine: inizializza secondo la <em>dichiarazione</em> dei membri (non “forzare” ordine nella lista).</li>
      </ul>
<pre><code class="language-cpp">class Wrapper {
private:
    const int id_;
    const std::string&amp; nome_;        // attenzione alla vita dell'oggetto referenziato!
public:
    Wrapper(int id, const std::string&amp; n) : id_{id}, nome_{n} {}
};</code></pre>
      <p class="warn"><b>Pericolo reference:</b> assicurati che l’oggetto referenziato viva almeno quanto il <code>Wrapper</code> (altrimenti dangling reference).</p>
    </div>

    <div class="inner-box box">
      <h2>Distruttore: quando serve davvero</h2>
      <ul>
        <li>Viene chiamato automaticamente quando l’oggetto esce di vita (fine blocco, <code>delete</code>, ecc.).</li>
        <li>Serve per <b>rilasciare risorse</b> (file, socket, memoria) quando non usi gestori automatici.</li>
        <li>In C++ moderno spesso vale la <b>Rule of Zero</b>: usa tipi che si gestiscono da soli (<code>std::string</code>, <code>std::vector</code>, <code>std::unique_ptr</code>) e raramente serve definire un distruttore.</li>
      </ul>
<pre><code class="language-cpp">#include &lt;fstream&gt;
class LogFile {
    std::ofstream out_;
public:
    LogFile(const std::string&amp; path) : out_{path} {} // niente explicit qui
    ~LogFile(){ /* out_ chiude il file nel suo distruttore */ }
    void write(const std::string&amp; s){ out_ &lt;&lt; s &lt;&lt; '\n'; }
};</code></pre>
      <p class="note">Qui il distruttore è superfluo: è mostrato solo per evidenziare l’evento di fine vita. <b>Preferisci RAII</b> (oggetti che gestiscono risorse automaticamente).</p>
    </div>

    <div class="inner-box box">
      <h2><code>= default</code> e <code>= delete</code> (accenno utile)</h2>
      <ul>
        <li><code>= default</code>: chiedi al compilatore l’implementazione “di default” (per costruttore/distruttore/copia/move quando la semantica naturale va bene).</li>
        <li><code>= delete</code>: vieti una costruzione/operazione (es. impedire la costruzione senza parametri).</li>
      </ul>
<pre><code class="language-cpp">class SoloConId {
    int id_;
public:
    SoloConId() = delete;               // vietato senza id
    SoloConId(int id) : id_{id} {}      // niente explicit in questa lezione
    ~SoloConId() = default;             // distruttore di default
};</code></pre>
      <p class="ok">Queste forme rendono le intenzioni <b>esplicite</b> e fanno fallire a compile-time gli usi non voluti.</p>
    </div>

    <div class="inner-box box">
      <h2>Inizializzatori di membro (default member initializer)</h2>
      <ul>
        <li>Puoi dare un <b>valore di default</b> ai membri dove li dichiari: es. <code>double x_{0.0};</code></li>
        <li>Se il costruttore specifica un valore nella lista, <b>quel valore prevale</b> sul default.</li>
      </ul>
<pre><code class="language-cpp">class Rettangolo {
private:
    double b_{1.0};
    double h_{1.0};
public:
    Rettangolo() = default;                         // usa i default: 1x1
    Rettangolo(double b, double h) : b_{b}, h_{h} {}  // prevale
    double area() const { return b_ * h_; }
};</code></pre>
      <p class="note">Combinare “default member initializer” + costruttori riduce ripetizione ed errori.</p>
    </div>

    <div class="inner-box box">
      <h2>Errore didattico classico: ordine di inizializzazione</h2>
      <p>Ricorda: l’ordine di inizializzazione segue <em>le dichiarazioni</em>, non la lista. Esempio per mostrare il problema:</p>
<pre><code class="language-cpp">class Demo {
private:
    int a_;
    int b_;
public:
    Demo(int x) : b_{x}, a_{b_} {}  // a_ verrà inizializzato PRIMA di b_ → uso non definito di b_
};</code></pre>
      <p class="warn"><b>Soluzione:</b> dichiara i membri nell’ordine logico in cui dipendono e inizializza coerentemente, oppure rimuovi dipendenze tra membri.</p>
    </div>

    <div class="inner-box box">
      <h2>Metodi <code>static</code>: cosa sono e perché usarli (esempio: <code>Orario::valido</code>)</h2>
      <ul>
        <li>Un <b>metodo statico</b> appartiene alla <b>classe</b>, non all’istanza: <strong>non</strong> riceve il puntatore <code>this</code>.</li>
        <li>Può essere chiamato senza creare oggetti: <code>Orario::valido(12,30,45)</code>.</li>
        <li><b>Non</b> può accedere ai membri non-static (perché manca <code>this</code>); può però usare costanti statiche o parametri passati.</li>
        <li>È utile per operazioni che appartengono “concettualmente” al tipo ma non dipendono dallo stato di una singola istanza (es. funzioni di <b>validazione</b>, <b>utility</b>).</li>
        <li>È comodo nei costruttori: puoi usarlo per verificare gli argomenti <em>prima</em> di inizializzare i campi.</li>
      </ul>
<pre><code class="language-cpp">#include &lt;string&gt;
#include &lt;iomanip&gt;
#include &lt;sstream&gt;

class Orario {
private:
    int hh_{0}, mm_{0}, ss_{0};                  // 0≤hh&lt;24, 0≤mm,ss&lt;60
    static bool valido(int h,int m,int s){       // metodo "di classe", niente this
        return 0 &lt;= h &amp;&amp; h &lt; 24 &amp;&amp; 0 &lt;= m &amp;&amp; m &lt; 60 &amp;&amp; 0 &lt;= s &amp;&amp; s &lt; 60;
    }
public:
    Orario() = default;
    Orario(int h,int m,int s) : hh_{0}, mm_{0}, ss_{0} {
        if(valido(h,m,s)){ hh_=h; mm_=m; ss_=s; } // uso interno del metodo statico
    }
    std::string to_string() const {
        std::ostringstream os;
        os &lt;&lt; std::setfill('0') &lt;&lt; std::setw(2) &lt;&lt; hh_ &lt;&lt; ":"
           &lt;&lt; std::setw(2) &lt;&lt; mm_ &lt;&lt; ":" &lt;&lt; std::setw(2) &lt;&lt; ss_;
        return os.str();
    }
};

int main(){
    // Chiamata senza istanze: "controllo puro" di input
    bool ok = Orario::valido(23,59,58);  // OK: metodo di classe
    (void)ok;
}</code></pre>
      <p class="ok"><b>Perché <code>static</code> qui?</b> <code>valido</code> non dipende dallo stato di un oggetto specifico; è un controllo generale sul <em>formato</em> dell’orario. Dichiararlo <code>static</code> chiarisce l’intento, evita accessi allo stato e permette l’uso anche prima di avere un’istanza.</p>
    </div>

    <div class="inner-box box">
      <h2>Esempio completo: progettare <code>Orario</code> con invarianti</h2>
<pre><code class="language-cpp">class Orario {
private:
    int hh_{0}, mm_{0}, ss_{0};                  // 0≤hh&lt;24, 0≤mm,ss&lt;60
    static bool valido(int h,int m,int s){
        return 0 &lt;= h &amp;&amp; h &lt; 24 &amp;&amp; 0 &lt;= m &amp;&amp; m &lt; 60 &amp;&amp; 0 &lt;= s &amp;&amp; s &lt; 60;
    }
public:
    Orario() = default;
    Orario(int h,int m,int s) : hh_{0}, mm_{0}, ss_{0} {
        if(valido(h,m,s)){ hh_=h; mm_=m; ss_=s; } // valida e imposta
    }
    std::string to_string() const; // come sopra
};</code></pre>
      <p class="note">L’oggetto nasce sempre valido: o prende i valori corretti, o cade su un default sicuro (00:00:00). Il controllo è centralizzato in un <code>static</code> “di classe”.</p>
    </div>

    <div class="inner-box box">
      <h2>Pitfall comuni (e rimedi pratici)</h2>
      <ul>
        <li><strong>Assegnare nel corpo</strong> ciò che andava inizializzato nella lista. <br/><br/><span class="ok">Usa sempre la <b>lista di inizializzazione</b> per portare i membri al primo valore.</span></li>
        <li><strong>Dimenticare <code>const</code>/<code>&amp;</code></strong> nella lista. <br/><br/><span class="ok">Membri <b>const</b>/<b>reference</b> vanno inizializzati nella lista, punto.</span></li>
        <li><strong>Ordine sbagliato</strong> tra membri e lista. <br/><br/><span class="ok">La costruzione segue l’ordine di <em>dichiarazione</em>; riordina i membri.</span></li>
        <li><strong>Confusione sui metodi <code>static</code></strong>. <br/><br/><span class="ok">Ricorda: niente <code>this</code>, niente accesso a campi non-static; usali per controlli/utility “di classe”.</span></li>
      </ul>
    </div>

    <div class="inner-box box">
      <h2>Esercizi (con soluzione a comparsa)</h2>
      <ol>
        <li><b>E1 — <code>Rettangolo</code> robusto</b><br/>
          <em>Testo:</em> Scrivi costruttore default (1x1) e parametrico che rifiuta lati ≤ 0; aggiungi <code>area()</code>.
          <div class="nav-buttons" style="justify-content:left"><button id="btn-e1" onclick="toggleBox('btn-e1','box-e1')">Mostra ▼</button></div>
          <div id="box-e1" style="display:none;margin-top:8px">
<pre><code class="language-cpp">class Rettangolo {
    double b_{1.0};
    double h_{1.0};
public:
    Rettangolo() = default;
    Rettangolo(double b,double h) : b_{ (b&gt;0?b:1.0) }, h_{ (h&gt;0?h:1.0) } {}
    double area() const { return b_ * h_; }
};</code></pre>
          </div>
        </li>

        <li><b>E2 — <code>Libro</code> con membro <code>const</code></b><br/>
          <em>Testo:</em> Crea una classe con <code>const int isbn_;</code> che deve essere impostato nel costruttore.
          <div class="nav-buttons" style="justify-content:left"><button id="btn-e2" onclick="toggleBox('btn-e2','box-e2')">Mostra ▼</button></div>
          <div id="box-e2" style="display:none;margin-top:8px">
<pre><code class="language-cpp">class Libro {
    const int isbn_;
    std::string titolo_;
public:
    Libro(int isbn, std::string t) : isbn_{isbn}, titolo_{std::move(t)} {}
    int isbn() const { return isbn_; }
};</code></pre>
          </div>
        </li>

        <li><b>E3 — Ordine di inizializzazione</b><br/>
          <em>Testo:</em> Correggi la classe seguente affinché <code>a_</code> sia inizializzato usando il valore di <code>b_</code> in modo definito.
<pre><code class="language-cpp">class Demo {
    int a_;
    int b_;
public:
    Demo(int x) : b_{x}, a_{b_} {}
};</code></pre>
          <div class="nav-buttons" style="justify-content:left"><button id="btn-e3" onclick="toggleBox('btn-e3','box-e3')">Mostra ▼</button></div>
          <div id="box-e3" style="display:none;margin-top:8px">
<pre><code class="language-cpp">class Demo {
    int b_;
    int a_;
public:
    Demo(int x) : b_{x}, a_{b_} {}   // ora l'ordine delle dichiarazioni rende definito l'uso
};</code></pre>
          </div>
        </li>
      </ol>
    </div>

    <div class="inner-box note">
      <b>Prossimi passi.</b> Nella <strong>Lez4_4</strong>: <b>incapsulamento forte</b>, metodi <code>const</code> ben progettati e <b>overload</b> per interfacce più naturali.
    </div>

  </div>

  <div class="nav-buttons">
    <button onclick="prevSlide()">&#8592; Indietro</button>
    <button onclick="nextSlide()">Avanti &#8594;</button>
  </div>
</div>

<script>
function toggleMenu(){ document.getElementById('menu').classList.toggle('open'); }
</script>
</body>
</html>
