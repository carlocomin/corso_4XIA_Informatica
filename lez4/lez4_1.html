<!DOCTYPE html>
<html lang="it">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>4BIA – Lez4_1 · Perché OOP? Concetti di base</title>

  <!-- Template base -->
  <link rel="stylesheet" href="../style.css">
  <link rel="stylesheet" href="../default.css">
  <script src="../highlight.js"></script>
  <script>try{hljs.highlightAll();}catch(e){}</script>

  <script>
    function prevSlide(){ window.location.href = "../programma.html"; }
    function nextSlide(){ window.location.href = "lez4_2.html"; }
    function toggleMenu(){ document.getElementById('menu').classList.toggle('open'); }
    function toggleBox(btnId, boxId){
      const box = document.getElementById(boxId);
      const btn = document.getElementById(btnId);
      const open = box.style.display === 'block';
      box.style.display = open ? 'none' : 'block';
      if(btn) btn.textContent = open ? 'Mostra ▼' : 'Nascondi ▲';
    }
  </script>

  <style>
    /* Forza allineamento a sinistra in ogni inner-box */
    .inner-box, .inner-box p, .inner-box ul, .inner-box ol, .inner-box li,
    .inner-box pre, .inner-box code, .inner-box h2, .inner-box h3 { text-align:left !important; }
    .inner-box ul, .inner-box ol { margin:.5rem 0 .75rem 1rem; padding-left:1.25rem; list-style-position:outside }
    .inner-box li { margin:.25rem 0 }
    pre, pre code { white-space:pre; tab-size:4; margin:0 0 1rem 0; padding:.5rem .75rem; }
    code { white-space:pre-wrap; }

    /* Box colorati per enfasi */
    .box  { background:var(--panel,#fff); border-radius:12px; padding:12px; box-shadow:0 2px 6px rgba(0,0,0,.08); margin-bottom:14px }
    .note { background:#f7faff; border-left:4px solid #3b82f6; padding:.6rem .8rem; border-radius:8px; margin:.35rem 0 }
    .ok   { background:#eefbf1; border-left:4px solid #22c55e; padding:.6rem .8rem; border-radius:8px; margin:.35rem 0; display:inline-block }
    .warn { background:#fff7ed; border-left:4px solid #f59e0b; padding:.6rem .8rem; border-radius:8px; margin:.35rem 0 }
    .kbd  { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace; background:#f1f5f9; border:1px solid #e2e8f0; border-radius:6px; padding:0 .35rem }

    table { width:100%; border-collapse:collapse }
    th, td { border-bottom:1px solid #e5e7eb; padding:.45rem .5rem; text-align:left; vertical-align:top }
    th { background:#f8fafc }
  </style>
</head>
<body>

<!-- MENU -->
<button class="menu-toggle" onclick="toggleMenu()">&#9776; Menu</button>
<div class="sidebar" id="menu">
  <h2>Lezione 4 — OOP in C++ (introduzione)</h2>
  <ul>
    <li><a class="active" href="lez4_1.html">Lez4_1: Perché OOP? Concetti di base</a></li>
    <li><a href="lez4_2.html">Lez4_2: Definire una classe (sintassi minima)</a></li>
    <li><a href="lez4_3.html">Lez4_3: Costruttori, distruttore, lista d’iniz.</a></li>
    <li><a href="lez4_4.html">Lez4_4: Incapsulamento, metodi const, overload</a></li>
    <li><a href="lez4_5.html">Lez4_5: to_string(), stampa, pre/postcondiz.</a></li>
    <li><a href="lez4_6.html">Lez4_6: Header/Sorgenti, include-guard, build</a></li>
  </ul>
</div>

<div class="slide">
  <h1>Perché OOP? Concetti di base (C++)</h1>

  <div class="nav-buttons" style="margin-bottom:10px">
    <button onclick="prevSlide()">&#8592; Indietro</button>
    <button onclick="nextSlide()">Avanti &#8594;</button>
  </div>

  <div class="content-box">

    <div class="inner-box box">
      <h2>Obiettivi della lezione</h2>
      <ul>
        <li>Capire il <strong>perché</strong> della programmazione a oggetti (OOP) rispetto allo stile procedurale.</li>
        <li>Imparare il vocabolario minimo: <strong>classe</strong>, <strong>oggetto</strong>, <strong>stato</strong>, <strong>comportamento</strong>, <strong>interfaccia</strong>, <strong>invarianti</strong>.</li>
        <li>Vedere esempi semplici e <strong>pattern</strong> di progettazione base (incapsulamento).</li>
      </ul>
      <p class="ok"><b>Idea chiave:</b> l’OOP aiuta a gestire la complessità raggruppando dati e operazioni coerenti nello stesso modulo: <em>l’oggetto</em>.</p>
    </div>

    <div class="inner-box box">
      <h2>Motivazioni: perché OOP?</h2>
      <ul>
        <li><b>Incapsulamento</b>: nasconde i dettagli interni, espone solo l’API necessaria.</li>
        <li><b>Astrazione</b>: modelli il “tipo” che ti serve (es. <code>Punto</code>, <code>Orario</code>, <code>Conto</code>), non i soli tipi primitivi.</li>
        <li><b>Coesione alta &amp; accoppiamento basso</b>: ogni classe ha una responsabilità chiara; le dipendenze tra moduli restano semplici.</li>
        <li><b>Riuso controllato</b>: istanzi diversi oggetti, componi classi, riusi codice senza copia/incolla.</li>
        <li><b>Testabilità</b>: API piccole e stabili ⇒ più facile scrivere test unitari e fare refactor.</li>
      </ul>
      <p class="note">L’OOP non è una panacea: è uno strumento. Lo useremo con buon senso, partendo da casi semplici e concreti.</p>
    </div>

    <div class="inner-box box">
      <h2>Vocabolario minimo</h2>
      <ul>
        <li><b>Classe</b>: progetto/tipo astratto (dichiara <em>stato</em> e <em>metodi</em>).</li>
        <li><b>Oggetto</b>: istanza concreta della classe (vive in memoria; ha <em>identità</em>).</li>
        <li><b>Stato</b>: insieme di campi (dati) che descrivono l’oggetto in un certo momento.</li>
        <li><b>Comportamento</b>: metodi/operazioni che l’oggetto sa eseguire.</li>
        <li><b>Interfaccia</b>: la parte <code>public</code> che un utente può chiamare; il contratto d’uso.</li>
        <li><b>Invariante</b>: proprietà che deve rimanere vera per ogni istanza valida (es. saldo ≥ 0).</li>
      </ul>
      <p class="ok"><b>Focus:</b> a parità di funzionalità, preferisci un’API più semplice e con regole chiare (contratto esplicito).</p>
    </div>

    <div class="inner-box box">
      <h2>Procedurale vs OOP (confronto pratico)</h2>
      <table>
        <thead><tr><th>Procedurale</th><th>OOP</th></tr></thead>
        <tbody>
          <tr>
            <td>Strutture dati “passive” + funzioni libere.</td>
            <td>Dati + metodi nello stesso involucro (<b>classe</b>).</td>
          </tr>
          <tr>
            <td>Validazioni disperse in molte funzioni.</td>
            <td>Validazioni centralizzate nell’API (<b>incapsulamento</b>).</td>
          </tr>
          <tr>
            <td>Più facile “rompere” lo stato per errore.</td>
            <td>Invarianti difese dai metodi pubblici.</td>
          </tr>
          <tr>
            <td>Accoppiamento spesso alto tra moduli.</td>
            <td>Accoppiamento più basso grazie a interfacce chiare.</td>
          </tr>
        </tbody>
      </table>
      <p class="note">Entrambi gli stili sono utili. In questa unità useremo C++ per vedere come tradurre i concetti OOP in codice.</p>
    </div>

    <div class="inner-box box">
      <h2>Esempio didattico: il tipo <code>Punto</code> (stato + operazioni)</h2>
<pre><code class="language-cpp">#include &lt;cmath&gt;
#include &lt;string&gt;
#include &lt;sstream&gt;

class Punto {
private:
    double x_{0.0}, y_{0.0};   // STATO: coordinate
    static bool finito(double v){ return std::isfinite(v); } // utility di classe
public:
    // COSTRUZIONE: oggetti sempre validi
    Punto() = default;
    Punto(double x, double y) : x_{x}, y_{y} {}

    // OPERAZIONI: mutatori + osservatori (const)
    bool set(double nx, double ny){
        if(!finito(nx) || !finito(ny)) return false;
        x_ = nx; y_ = ny; return true;
    }
    void sposta_rel(double dx, double dy){ x_ += dx; y_ += dy; }
    double x() const { return x_; }
    double y() const { return y_; }
    double norm() const { return std::sqrt(x_*x_ + y_*y_); }

    // RAPPRESENTAZIONE TESTUALE
    std::string to_string() const {
        std::ostringstream os; os &lt;&lt; "(" &lt;&lt; x_ &lt;&lt; "," &lt;&lt; y_ &lt;&lt; ")";
        return os.str();
    }
};</code></pre>
      <ul>
        <li><b>Incapsulamento</b>: i campi sono privati; l’esterno usa metodi controllati.</li>
        <li><b>Osservatori const</b>: <code>x()</code>, <code>y()</code>, <code>norm()</code> non modificano lo stato.</li>
        <li><b>Invariante implicita</b>: coordinate finite (controllata in <code>set</code>).</li>
      </ul>
      <div class="nav-buttons" style="justify-content:left">
        <button id="btn-demo" onclick="toggleBox('btn-demo','box-demo')">Mostra ▼</button>
      </div>
      <div id="box-demo" style="display:none;margin-top:8px">
<pre><code class="language-cpp">#include &lt;iostream&gt;

int main(){
    Punto p;                       // (0,0)
    p.sposta_rel(3,4);
    std::cout &lt;&lt; p.to_string() &lt;&lt; " norm=" &lt;&lt; p.norm() &lt;&lt; "\n";

    const Punto q{1,2};           // oggetto const
    std::cout &lt;&lt; "q.x=" &lt;&lt; q.x() &lt;&lt; " q.y=" &lt;&lt; q.y() &lt;&lt; "\n"; // ok: metodi const
}</code></pre>
      </div>
    </div>

    <div class="inner-box box">
      <h2>API e contratto d’uso</h2>
      <ul>
        <li><b>Interfaccia minima</b>: esponi solo ciò che serve a chi usa la classe.</li>
        <li><b>Precondizioni/Postcondizioni</b>: documenta requisiti degli argomenti e risultati garantiti.</li>
        <li><b>Nome dei metodi</b>: osservatori “banali” ⇒ nomi brevi (<code>x()</code>); operazioni costose/che possono fallire ⇒ verbi espliciti (<code>compute…</code>, <code>load…</code>).</li>
      </ul>
      <p class="ok">Un’API chiara riduce i bug e rende più facile cambiare l’implementazione senza toccare il codice client.</p>
    </div>

    <div class="inner-box box">
      <h2>Come “scomporre” un problema in classi</h2>
      <ol>
        <li><b>Individua gli oggetti</b> del dominio (nouns: Punto, Segmento, Rettangolo, Orario, Conto…).</li>
        <li><b>Definisci lo stato</b> necessario e gli <b>invarianti</b> (proprietà sempre vere).</li>
        <li><b>Progetta l’interfaccia</b> (metodi pubblici): cosa deve poter fare l’oggetto?</li>
        <li><b>Nascondi i dettagli</b> d’implementazione (<code>private</code>): lascia libertà di refactoring.</li>
      </ol>
      <p class="note">Parti semplice; refactora via via che emergono nuove esigenze. Evita “classi Dio” che fanno tutto.</p>
    </div>

    <div class="inner-box box">
      <h2>Pitfall comuni (e rimedi pratici)</h2>
      <ul>
        <li><strong>Campi pubblici</strong> “per comodità” → invarianti violabili. <br/><br/><span class="ok">Rendi i campi <code>private</code> e valida nei metodi.</span></li>
        <li><strong>API enorme</strong> con metodi superflui. <br/><br/><span class="ok">Inizia con un set minimo; aggiungi solo quando serve davvero.</span></li>
        <li><strong>Mescolare logica e I/O</strong> nella stessa classe. <br/><br/><span class="ok">Separa responsabilità (SRP): calcolo da una parte, formattazione/stampa dall’altra.</span></li>
        <li><strong>Dimenticare gli osservatori <code>const</code></strong>. <br/><br/><span class="ok">Segna <code>const</code> i metodi che non mutano lo stato.</span></li>
      </ul>
    </div>

    <div class="inner-box note">
      <b>Prossimo:</b> in <strong>Lez4_2</strong> vediamo la <strong>sintassi minima</strong> per dichiarare una classe, l’uso di <code>public</code>/<code>private</code> e i primi metodi.
    </div>

  </div>

  <div class="nav-buttons">
    <button onclick="prevSlide()">&#8592; Indietro</button>
    <button onclick="nextSlide()">Avanti &#8594;</button>
  </div>
</div>

<script>
  function toggleMenu(){ document.getElementById('menu').classList.toggle('open'); }
</script>
</body>
</html>
